<?php

include_once 'bgpage.features.inc';

/**
 * Implementation of hook_menu().
 */
function bgpage_menu() {
  $items = array();

  // Taxonomy tab.
  $items['node/%bgpage_node/tree'] = array(
    'title' => 'Taxonomy',
    'page callback' => 'bgpage_tree',
    'page arguments' => array(1),
    'access callback' => 'bg_menu_access',
    'access arguments' => array(1),
    'weight' => -1,
    'type' => MENU_LOCAL_TASK,
    'file' => 'bgpage.pages.inc',
  );

  // Browse tab.
  $items['node/%bgpage_node/bgpage'] = array(
    'title' => 'Browse',
    'page callback' => 'bgpage_browse',
    'page arguments' => array(1),
    'access callback' => 'bg_menu_access',
    'access arguments' => array(1),
    'weight' => 1,
    'type' => MENU_LOCAL_TASK,
    'file' => 'bgpage.pages.inc',
  );

  // Browse tab.
  $items['node/%bgpage_node/bgimage'] = array(
    'title' => 'Images',
    'page callback' => 'bgpage_images',
    'page arguments' => array(1),
    'access callback' => 'bg_menu_access',
    'access arguments' => array(1),
    'weight' => 1,
    'type' => MENU_LOCAL_TASK,
    'file' => 'bgpage.pages.inc',
  );

  return $items;
}

/**
 * Wildcard resolver for Browse tab.
 *
 * For bgpage we return the nid, while for bgmage we return the immediate parent.
 */
function bgpage_node_to_arg($arg, $map, $index) {
  if ($arg == '%') {
    return NULL;
  }

  $node = node_load($arg);
  if (empty($node)) {
    return NULL;
  }

  if ($node->type == 'bgpage') {
    return $arg;
  }
  elseif ($node->type == 'bgimage') {
    return bg_get_parent_nid($node);
  }

  return NULL;
}

/**
 * Implements hook_ds_fields_info().
 */
function bgpage_ds_fields_info($entity_type) {
  $fields = array();

  if ($entity_type == 'node') {
    $fields['bgpage_classification'] = array(
      'title' => t('Classification'),
      'description' => t('Renders the classification tree for a Guide Page.'),
      'field_type' => DS_FIELD_TYPE_FUNCTION,
      'function' => '_bgpage_classification',
      'file' => drupal_get_path('module', 'bgpage') . '/bgpage.ds.field.inc',
    );

    $fields['bgpage_citations'] = array(
      'title' => t('Works cited'),
      'field_type' => DS_FIELD_TYPE_FUNCTION,
      'function' => '_bgpage_citations',
      'file' => drupal_get_path('module', 'bgpage') . '/bgpage.ds.field.inc',
    );

    $fields['bgpage_browse'] = array(
      'title' => t('Browse images per children'),
      'field_type' => DS_FIELD_TYPE_FUNCTION,
      'function' => '_bgpage_browse',
      'file' => drupal_get_path('module', 'bgpage') . '/bgpage.ds.field.inc',
    );

    $fields['bgpage_images'] = array(
      'title' => t('Browse all images'),
      'field_type' => DS_FIELD_TYPE_FUNCTION,
      'function' => '_bgpage_images',
      'file' => drupal_get_path('module', 'bgpage') . '/bgpage.ds.field.inc',
    );

    return array($entity_type => $fields);
  }
  return;
}

/**
 * Change "View" tab to say "Info".
 */
function bgpage_menu_alter(&$items) {
  $items['node/%node/view']['title'] = t('Info');
}

function bgpage_permission() {
  return array(
    'view taxon ID field' => array(
      'title' => 'View taxon ID field',
    ),
    'view who edited bgpage' => array(
      'title' => 'View who edited a bgpage',
    ),
    'view raw parents' => array(
      'title' => 'View raw parents',
    ),
  );
}

function bgpage_theme() {
  return array(
    'bgpage_classification' => array(
      'arguments' => array('node' => NULL),
    ),
    'bgpage_tree' => array(
      'arguments' => array('children' => NULL, 'nids' => NULL, 'taxons' => NULL, 'titles' => NULL, 'scientific_names' => NULL),
    ),
    'bgpage_taxonomy_reorder' => array(
      'arguments' => array('element' => NULL),
    ),
  );
}

/**
 * Implements hook_form_FORM_ID_alter()
 *
 * Assumption: this form is only used for editing, not new nodes.
 * New nodes are created with the bgpage quickadd form.
 */
function bgpage_form_bgpage_node_form_alter(&$form, &$form_state, $form_id) {
  $node = $form['#entity'];

  //$form['title']['#access'] = FALSE;
  if (!user_access('view taxon ID field')) {
    $form['field_taxon']['#access'] = FALSE;
  }
  if (!user_access('view who edited bgpage')) {
    $form['field_editors']['#access'] = FALSE;
  }
  if (!user_access('view raw parents')) {
    $form['field_parents']['#access'] = FALSE;
  }

  // Run our validator after the regular node validator runs.
  $form['#validate'][] = 'bgpage_node_form_validate';

}

/**
 * Form validate callback for bgpage nodes.
 */
function bgpage_node_form_validate(&$form, &$form_state) {
  global $TAXON_NAMES, $TAXON_IDS;

  $scientific_name = NULL;

  $values = $form_state['values'];

  if (!isset($TAXON_NAMES[$values['field_taxon'][LANGUAGE_NONE][0]['value']])) {
    $taxon_name = t('No Taxon');
  }
  else {
    $taxon_name = $TAXON_NAMES[$values['field_taxon'][LANGUAGE_NONE][0]['value']];
  }

  if ($taxon_name == t('No Taxon')) {
    // TODO this should really hide the field in form_alter()

    // Check if this is a duplicate entry.
    // TODO update for D7
    //$nid = db_result(db_query("SELECT n.nid FROM {node} n JOIN {bgpage} p ON p.nid = n.nid WHERE n.title = '%s' AND p.parent = '%s' AND n.nid != %d", $node->title, $node->parent, $node->nid));
    // Criteria: has same parent, also has same title, also is not this node (if editing)
    $query = new EntityFieldQuery;
    $query->entityCondition('entity_type', 'node')
          ->entityCondition('bundle', 'bgpage')
          ->propertyCondition('title', $values['title'])
          ->fieldCondition('field_parent', 'value', $values['field_parent'][LANGUAGE_NONE][0]['value']);
    // Existing nodes have nids.
    // In that case we want the query to exclude the nid of this node
    // because it is silly to alert that this node has the same title as this node.
    if (isset($values['nid'])) {
      $query->propertyCondition('nid', $values['nid'], '<>');
    }
    $result = $query->execute();
    if (!empty($result['node'])) {
      foreach ($result['node'] as $nid => $info) {
        form_set_error('', t('There is a <a href="!link" target="_blank">guide page</a> with that title and parent.', array(
          '!link' => url('node/' . $nid),
        )));
      }
    }
  }
  elseif (isset($values['field_scientific_name'][LANGUAGE_NONE][0]['value'])) {
    $scientific_name = trim($values['field_scientific_name'][LANGUAGE_NONE][0]['value']);
    if (!$scientific_name) {
      form_set_error('field_scientific_name', t('You must specify a scientific name.'));
    }
    elseif (strpos($scientific_name, ' ')) {
      form_set_error('field_scientific_name', t('Scientific name should be one word only.'));
    }
    elseif (preg_match("/[^A-Za-z-]/", $scientific_name) > 0) {
      form_set_error('field_scientific_name', t("Only the letters 'a' to 'z' are allowed."));
    }
    elseif (($taxon_name == "Superfamily") && !bg_str_ends_with($values['field_scientific_name'][LANGUAGE_NONE][0]['value'], "oidea")) {
      form_set_error('field_scientific_name', t("A superfamily name should end with 'oidea'."));
    }
    elseif (($taxon_name == "Family") && !bg_str_ends_with($scientific_name, "idae")) {
      form_set_error('field_scientific_name', t("A family name should end with 'idae'."));
    }
    elseif (($taxon_name == "Subfamily") && !bg_str_ends_with($scientific_name, "inae")) {
      form_set_error('field_scientific_name', t("A subfamily name should end with 'inae'."));
    }
    elseif (($taxon_name == "Species") || ($taxon_name == "Subspecies")) {
      $scientific_name = strtolower($scientific_name);
      $query = new EntityFieldQuery;
      $query->entityCondition('entity_type', 'node')
            ->entityCondition('bundle', 'bgpage')
            ->fieldCondition('field_scientific_name', 'value', $scientific_name)
            ->fieldCondition('field_taxon', 'value', $values['field_taxon'][LANGUAGE_NONE][0]['value'])
            ->fieldCondition('field_parent', 'value', $values['field_parent'][LANGUAGE_NONE][0]['value']);
      // Existing nodes have nids.
      // In that case we want the query to exclude the nid of this node
      // because it is silly to alert that this node has the same title as this node.
      if (isset($values['nid'])) {
        $query->propertyCondition('nid', $values['nid'], '<>');
      }
      $result = $query->execute();
      if (!empty($result['node'])) {
        foreach ($result['node'] as $nid => $info) {
          form_set_error('', t('There is a <a href="!link" target="_blank">guide page</a> with that scientific name, taxon and parent.', array(
            '!link' => url('node/' . $nid),
          )));
        }
      }
    }
    else {
      $scientific_name = ucfirst(strtolower($scientific_name));
      $query = new EntityFieldQuery;
      $query->entityCondition('entity_type', 'node')
            ->entityCondition('bundle', 'bgpage')
            ->fieldCondition('field_scientific_name', 'value', $scientific_name)
            ->fieldCondition('field_taxon', 'value', $values['field_taxon'][LANGUAGE_NONE][0]['value']);
      // Existing nodes have nids.
      // In that case we want the query to exclude the nid of this node
      // because it is silly to alert that this node has the same title as this node.
      if (isset($values['nid'])) {
        $query->propertyCondition('nid', $values['nid'], '<>');
      }
      $result = $query->execute();
      if (!empty($result['node'])) {
        foreach ($result['node'] as $nid => $info) {
          form_set_error('', t('There is a <a href="!link" target="_blank">guide page</a> with that scientific name and taxon.', array(
            '!link' => url('node/' . $nid),
          )));
        }
      }
    }
  }

  // Pass value forward to submit function.
  $form_state['values']['taxon_name'] = $taxon_name;
  $form_state['values']['scientific_name'] = $scientific_name;
}

/**
 * Implements hook_apachesolr_index_document_build_node().
 */
function bgpage_apachesolr_index_document_build_node($document, $entity, $env_id) {
  if ($entity->type !== 'bgpage') {
    return;
  }

  // Classification field used for sorting.
  $classification = '';
  if (!empty($entity->field_parent[LANGUAGE_NONE][0]['value'])) {
    $classification = $entity->field_parent[LANGUAGE_NONE][0]['value'] . ',';
  }
  $classification .= $entity->nid;
  $document->addField('ss_bgpage_classification', $classification);

  // Parents field used for searching for descendants.
  $parents = array();
  if (!empty($entity->field_parent[LANGUAGE_NONE][0]['value'])) {
    $parents = explode(',', $entity->field_parent[LANGUAGE_NONE][0]['value']);
  }
  foreach ($parents as $parent) {
    $document->addField('sm_bgpage_parents', $parent);
  }

  // Immediate parent field used for searching direct descendants.
  $parent_nid = bg_get_parent_nid($entity);
  if ($parent_nid != NULL) {
    $document->addField('ss_bgpage_immediate_parent', $parent_nid);
  }
}

/**
 * Builds a hierarchy tree for a set of related nodes.
 *
 * @param array $results
 *   An array of Apache Solr search results.
 * @returns string
 *   The rendered HTML that represents the tree.
 */
function bgpage_tree_build($results) {
  global $TAXON_NAMES, $TAXON_IDS;
  $output = '<span class="graytext">Kingdom</span> <strong>Animalia</strong> - Animals<br/>';

  foreach ($results as $result) {
    // Calculate indentation.
    $indents = count(explode(',', $result->ss_bgpage_classification));
    $indents = str_repeat('&nbsp;', ($indents) * 2);

    // Render the element.
    $output .= $indents . bgpage_tree_child($result);
    $output .= '</br>';

  }

  return $output;
}

/**
 * Renders a tree element.
 *
 * @param object result
 *   An Apache Solr search result.
 * @return string
 *   The rendered tree item.
 */
function bgpage_tree_child($result) {
  global $TAXON_NAMES, $TAXON_IDS;
  if (!empty($result->its_field_taxon) && isset($TAXON_NAMES[$result->its_field_taxon])) {
    $taxon_name = $TAXON_NAMES[$result->its_field_taxon];
    $taxon_id = $result->its_field_taxon;
  }
  else {
    $taxon_name = t('No Taxon');
    $taxon_id = NULL;
  }

  $scientific_name = $result->label;
  if (!empty($result->sm_field_scientific_name)) {
    $scientific_name = $result->sm_field_scientific_name[0];
  }

  $output = "<span class=\"bgpage-taxon-title\">$taxon_name </span>";
  $italics = $taxon_id >= $TAXON_IDS["Genus"];
  $output .= "<span class=\"bgpage-taxon-desc\">";
  if ($italics) {
    $output .= "<i>";
  }
  $output .= l("<strong>$scientific_name</strong>", "node/" . $result->entity_id . "/tree", array('html' => TRUE));
  if ($italics) {
    $output .= "</i>";
  }
  if ($result->label != $scientific_name) {
    $output .= " - " . $result->label;
  }
  if (!empty($result->sm_field_hodges_number)) {
    $output .= " - Hodges#" . $result->sm_field_hodges_number[0];
  }
  
  // Add number of children for this taxon in parentheses if nonzero.
  // TODO add caching here as LIKE queries are expensive. 
  //$search_path = $child->parent . ','. $child->nid;
  $search_path = $result->ss_bgpage_classification; // 3,456,789
  $child_count = db_query("SELECT COUNT(nid) FROM {bgimage} WHERE parent_idx LIKE '$search_path,%'")->fetchField();
  $child_count_string = $child_count ? ' ('. $child_count .')' : '';
  $output .= "$child_count_string</span><br />\n";
  return $output;
}

/**
 * Fetches classification details for a set of nids.
 *
 * @param int $nid
 *   The nid to use as the tree root.
 * @param object $filter
 *   SolrFilterSubQuery filter that defintes which elements to return.
 * @return array of ApacheSolr search result objects.
 */
function bgpage_fetch_classification($nid, $filter) {
  $results = array();

  try {
    $query = apachesolr_drupal_query('apachesolr', array());
    // Configure query.
    $query->addFilterSubQuery($filter);
    $query->addParam('fl', 'entity_id,label,ss_bgpage_classification,sm_field_hodges_number,its_field_taxon,sm_field_scientific_name');
    $query->addParam('rows', 10000000);
    $query->addParam('sort', 'sort_bgpage_classification asc');
    $query->addParam('sort', 'sort_label asc');

    // Run query and render results if matches are found.
    list($final_query, $response) = apachesolr_do_query($query);
    if ($response->code == '200' && $response->response->numFound > 0) {
      $results = $response->response->docs;
    }
    else {
      watchdog('bgpage', 'No results found for nid !nid', array('!nid' => $nid));
    }
  }
  catch (Exception $e) {
    watchdog('bgpage', 'Could not connect to Solr to fetch data for !nid. Error was %error.', array(
      '!nid' => $nid,
      '%error' => $e->getMessage(),
    ), WATCHDOG_ERROR);
  }

  return $results;
}
