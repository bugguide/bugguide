<?php

include_once 'bgpage.features.inc';

/**
 * Implementation of hook_menu().
 */
function bgpage_menu() {
  // Add the Taxonomy tab.
  $items['node/%bg_node/tree'] = array(
    'title' => 'Taxonomy',
    'page callback' => 'bgpage_tree',
    'page arguments' => array(1),
    'access callback' => 'bg_menu_access',
    'access arguments' => array(1),
    'weight' => -1,
    'type' => MENU_LOCAL_TASK,
  );
  // Add the Browse tab.
  $items['node/%bg_node/bgpage'] = array(
    'title' => 'Browse',
    'page callback' => 'bgpage_browse',
    'page arguments' => array(1),
    'access callback' => 'bg_menu_access',
    'access arguments' => array(1),
    'weight' => 1,
    'type' => MENU_LOCAL_TASK,
  );

  return $items;
}

/**
 * Implements hook_ds_fields_info().
 */
function bgpage_ds_fields_info($entity_type) {
  $fields = array();

  if ($entity_type == 'node') {
    $fields['bgpage_classification'] = array(
      'title' => t('Classification'),
      'description' => t('Renders the classification tree for a Guide Page.'),
      'field_type' => DS_FIELD_TYPE_FUNCTION,
      'function' => '_bgpage_classification',
      'file' => drupal_get_path('module', 'bgpage') . '/bgpage.ds.field.inc',
    );

    $fields['bgpage_citations'] = array(
      'title' => t('Works cited'),
      'field_type' => DS_FIELD_TYPE_FUNCTION,
      'function' => '_bgpage_citations',
      'file' => drupal_get_path('module', 'bgpage') . '/bgpage.ds.field.inc',
    );

    return array($entity_type => $fields);
  }
  return;
}

/**
 * Change "View" tab to say "Info".
 */
function bgpage_menu_alter(&$items) {
  $items['node/%node/view']['title'] = t('Info');
}

function bgpage_permission() {
  return array(
    'view taxon ID field' => array(
      'title' => 'View taxon ID field',
    ),
    'view who edited bgpage' => array(
      'title' => 'View who edited a bgpage',
    ),
    'view raw parents' => array(
      'title' => 'View raw parents',
    ),
  );
}

function bgpage_theme() {
  return array(
    'bgpage_classification' => array(
      'arguments' => array('node' => NULL),
    ),
    'bgpage_tree' => array(
      'arguments' => array('children' => NULL, 'nids' => NULL, 'taxons' => NULL, 'titles' => NULL, 'scientific_names' => NULL),
    ),
    'bgpage_taxonomy_reorder' => array(
      'arguments' => array('element' => NULL),
    ),
  );
}

/**
 * Implements hook_form_FORM_ID_alter()
 *
 * Assumption: this form is only used for editing, not new nodes.
 * New nodes are created with the bgpage quickadd form.
 */
function bgpage_form_bgpage_node_form_alter(&$form, &$form_state, $form_id) {
  $node = $form['#entity'];

  //$form['title']['#access'] = FALSE;
  if (!user_access('view taxon ID field')) {
    $form['field_taxon']['#access'] = FALSE;
  }
  if (!user_access('view who edited bgpage')) {
    $form['field_editors']['#access'] = FALSE;
  }
  if (!user_access('view raw parents')) {
    $form['field_parents']['#access'] = FALSE;
  }

  // Run our validator after the regular node validator runs.
  $form['#validate'][] = 'bgpage_node_form_validate';

}

/**
 * Form validate callback for bgpage nodes.
 */
function bgpage_node_form_validate(&$form, &$form_state) {
  global $TAXON_NAMES, $TAXON_IDS;

  $scientific_name = NULL;

  $values = $form_state['values'];

  if (!isset($TAXON_NAMES[$values['field_taxon'][LANGUAGE_NONE][0]['value']])) {
    $taxon_name = t('No Taxon');
  }
  else {
    $taxon_name = $TAXON_NAMES[$values['field_taxon'][LANGUAGE_NONE][0]['value']];
  }

  if ($taxon_name == t('No Taxon')) {
    // TODO this should really hide the field in form_alter()

    // Check if this is a duplicate entry.
    // TODO update for D7
    //$nid = db_result(db_query("SELECT n.nid FROM {node} n JOIN {bgpage} p ON p.nid = n.nid WHERE n.title = '%s' AND p.parent = '%s' AND n.nid != %d", $node->title, $node->parent, $node->nid));
    // Criteria: has same parent, also has same title, also is not this node (if editing)
    $query = new EntityFieldQuery;
    $query->entityCondition('entity_type', 'node')
          ->entityCondition('bundle', 'bgpage')
          ->propertyCondition('title', $values['title'])
          ->fieldCondition('field_parent', 'value', $values['field_parent'][LANGUAGE_NONE][0]['value']);
    // Existing nodes have nids.
    // In that case we want the query to exclude the nid of this node
    // because it is silly to alert that this node has the same title as this node.
    if (isset($values['nid'])) {
      $query->propertyCondition('nid', $values['nid'], '<>');
    }
    $result = $query->execute();
    if (!empty($result['node'])) {
      foreach ($result['node'] as $nid => $info) {
        form_set_error('', t('There is a <a href="!link" target="_blank">guide page</a> with that title and parent.', array(
          '!link' => url('node/' . $nid),
        )));
      }
    }
  }
  elseif (isset($values['field_scientific_name'][LANGUAGE_NONE][0]['value'])) {
    $scientific_name = trim($values['field_scientific_name'][LANGUAGE_NONE][0]['value']);
    if (!$scientific_name) {
      form_set_error('field_scientific_name', t('You must specify a scientific name.'));
    }
    elseif (strpos($scientific_name, ' ')) {
      form_set_error('field_scientific_name', t('Scientific name should be one word only.'));
    }
    elseif (preg_match("/[^A-Za-z-]/", $scientific_name) > 0) {
      form_set_error('field_scientific_name', t("Only the letters 'a' to 'z' are allowed."));
    }
    elseif (($taxon_name == "Superfamily") && !bugguide_str_ends_with($values['field_scientific_name'][LANGUAGE_NONE][0]['value'], "oidea")) {
      form_set_error('field_scientific_name', t("A superfamily name should end with 'oidea'."));
    }
    elseif (($taxon_name == "Family") && !bugguide_str_ends_with($scientific_name, "idae")) {
      form_set_error('field_scientific_name', t("A family name should end with 'idae'."));
    }
    elseif (($taxon_name == "Subfamily") && !bugguide_str_ends_with($scientific_name, "inae")) {
      form_set_error('field_scientific_name', t("A subfamily name should end with 'inae'."));
    }
    elseif (($taxon_name == "Species") || ($taxon_name == "Subspecies")) {
      $scientific_name = strtolower($scientific_name);
      $query = new EntityFieldQuery;
      $query->entityCondition('entity_type', 'node')
            ->entityCondition('bundle', 'bgpage')
            ->fieldCondition('field_scientific_name', 'value', $scientific_name)
            ->fieldCondition('field_taxon', 'value', $values['field_taxon'][LANGUAGE_NONE][0]['value'])
            ->fieldCondition('field_parent', 'value', $values['field_parent'][LANGUAGE_NONE][0]['value']);
      // Existing nodes have nids.
      // In that case we want the query to exclude the nid of this node
      // because it is silly to alert that this node has the same title as this node.
      if (isset($values['nid'])) {
        $query->propertyCondition('nid', $values['nid'], '<>');
      }
      $result = $query->execute();
      if (!empty($result['node'])) {
        foreach ($result['node'] as $nid => $info) {
          form_set_error('', t('There is a <a href="!link" target="_blank">guide page</a> with that scientific name, taxon and parent.', array(
            '!link' => url('node/' . $nid),
          )));
        }
      }
    }
    else {
      $scientific_name = ucfirst(strtolower($scientific_name));
      $query = new EntityFieldQuery;
      $query->entityCondition('entity_type', 'node')
            ->entityCondition('bundle', 'bgpage')
            ->fieldCondition('field_scientific_name', 'value', $scientific_name)
            ->fieldCondition('field_taxon', 'value', $values['field_taxon'][LANGUAGE_NONE][0]['value']);
      // Existing nodes have nids.
      // In that case we want the query to exclude the nid of this node
      // because it is silly to alert that this node has the same title as this node.
      if (isset($values['nid'])) {
        $query->propertyCondition('nid', $values['nid'], '<>');
      }
      $result = $query->execute();
      if (!empty($result['node'])) {
        foreach ($result['node'] as $nid => $info) {
          form_set_error('', t('There is a <a href="!link" target="_blank">guide page</a> with that scientific name and taxon.', array(
            '!link' => url('node/' . $nid),
          )));
        }
      }
    }
  }

  // Pass value forward to submit function.
  $form_state['values']['taxon_name'] = $taxon_name;
  $form_state['values']['scientific_name'] = $scientific_name;
}

/**
 * Add information to bgpage node(s).
 *
 * The information specific to each bgpage will load automatically
 * but the bgpage exists in a hierarchy. Information for each parent
 * of this bgpage needs to be retrieved efficiently.
 */
function bgpage_entity_load($entities, $type) {
  global $TAXON_NAMES, $TAXON_IDS;
  if ($type != 'node') {
    return;
  }

  // There are some known paths that we skip going through the extra work
  // of attaching parent and taxa data.
  $path_blacklist = array(
    'admin/content',
  );

  if (in_array($_GET['q'], $path_blacklist)) {
    return;
  }

  foreach ($entities as $node) {
    if ($node->type != 'bgpage' || isset($node->bgpage_entity_load)) {
      continue;
    }
    $node->bgpage_entity_load = TRUE;
    // Populate the hierarchy with taxon codes, titles and scientific names.
    $language = field_language('node', $node, 'field_parent');
    $parent_nids = array();
    // Only get parents if node has them.
    if (isset($node->field_parent[$language][0]['value'])) {
      $parent_nids = explode(',', $node->field_parent[$language][0]['value']);
    }
    $taxa = array();
    $titles = array();
    $scientific_names = array();
    $entities = array();

    // Create an array of basic entities so that the field values
    // for this set of parents can be retrieved all at once.
    foreach ($parent_nids as $parent_nid) {
      $entities[$parent_nid] = new stdClass();
      $entities[$parent_nid]->type = 'node';
      $entities[$parent_nid]->bundle = 'bgpage';
      $entities[$parent_nid]->id = $parent_nid;
    }

    $field_taxon_info = field_info_field('field_taxon');
    $options = array(
      'field_id' => $field_taxon_info['id'],
    );

    // Load taxon, title, scientific name info for all parents
    // without doing a full node load.
    field_attach_load('node', $entities, FIELD_LOAD_CURRENT, $options);

    // Check if a cached entity set loaded. Any entity id is good enough
    // to check for this so use the last parent nid from above.
    if (isset($parent_nid) && !isset($entities[$parent_nid]->field_scientific_name[$language][0]['value'])) {
      // We didn't hit a cached entity set; explicitly retrieve field values.
      $field_scientific_name_info = field_info_field('field_scientific_name');
      $options = array(
        'field_id' => $field_taxon_info['id'],
      );
      field_attach_load('node', $entities, FIELD_LOAD_CURRENT, $options);
    }

    foreach ($parent_nids as $parent_nid) {
      // taxon is a four-digit code defined in bugguide_globals.inc, in $TAXON_NAMES and $TAXON_IDs
      if (!empty($entities[$parent_nid]->field_taxon)) {
         $taxa[] = $entities[$parent_nid]->field_taxon[$language][0]['value'];
      }
      if (!empty($entities[$parent_nid]->field_scientific_name)) {
        $scientific_names[] = $entities[$parent_nid]->field_scientific_name[$language][0]['safe_value'];
      }

      $titles = array();
      if (!empty($entities[$parent_nid]->field_common_name)) {
        $titles[] = $entities[$parent_nid]->field_common_name[$language][0]['safe_value'];
      }
      if (!empty($entities[$parent_nid]->field_hodges_number)) {
        $titles[] =  'Hodges#' . $entities[$parent_nid]->field_hodges_number[$language][0]['value'];
      }
    }

    // Now for the node actually being loaded.
    if (empty($node->field_taxon)) {
      watchdog('bg', 'no taxon set for node !nid', array('!nid', $node->nid), WATCHDOG_WARNING);
    }
    else {
      $taxon = $node->field_taxon[$language][0]['value'];
      $taxa[] = $taxon;
    }

    if (isset($taxon)) {
      $taxon_name = isset($TAXON_NAMES[$taxon]) ? strtolower($TAXON_NAMES[$taxon]) : '';
      if ($taxon_name) {
        $node->taxon_name = $taxon_name;
      }
    }

    $node->taxa = implode('|', $taxa);
    $node->scientific_names = implode('|', $scientific_names);
    $node->titles = implode('|', $titles);
  }
}


/**
 * Menu callback for the Browse tab.
 */
function bgpage_browse($nid) {
  $node = node_load($nid);
  $PER_PAGE = 5;
  $node->comment = 0;
  $path = bgpage_get_path($node);
  $output = '';

  $stage_filter_sql = bgimage_get_stage_filter_sql();

  if (!$stage_filter_sql) {
    $result = pager_query("SELECT n.nid FROM {node} n, {bgpage} p WHERE p.nid = n.nid AND parent = '$path' AND status = '1' ORDER BY p.sequence, p.nid", $PER_PAGE);
  }
  else {
    //$result = pager_query("SELECT p.nid, count(*) FROM {node} n, {bgpage} p, {bgimage} i WHERE p.nid = n.nid AND p.parent = '$path' AND concat(i.parent,',') LIKE concat(p.parent,',',p.nid,',%') AND status = '1' AND representative = 1 AND $stage_filter GROUP BY p.nid ORDER BY p.sequence, p.nid", $PER_PAGE, 0, "SELECT count(distinct p.nid) FROM {node} n, {bgpage} p, {bgimage} i WHERE p.nid = n.nid AND p.parent = '$path' AND concat(i.parent,',') LIKE concat(p.parent,',',p.nid,',%') AND representative = 1 AND status = '1' AND $stage_filter");
    // now with parent_idx
    $result = pager_query("SELECT p.nid, COUNT(*) FROM {node} n, {bgpage} p, {bgimage} i WHERE p.nid = n.nid AND p.parent = '$path' AND i.parent_idx LIKE concat(p.parent,',',p.nid,',%') AND status = '1' AND representative = 1 $stage_filter_sql GROUP BY p.nid ORDER BY p.sequence, p.nid", $PER_PAGE, 0, "SELECT COUNT(distinct p.nid) FROM {node} n, {bgpage} p, {bgimage} i WHERE p.nid = n.nid AND p.parent = '$path' AND i.parent_idx LIKE concat(p.parent,',',p.nid,',%') AND representative = 1 AND status = '1' $stage_filter_sql");
  }

  while ($child = db_fetch_object($result)) {
    $count++;
    $child = node_load(array('nid' => $child->nid, 'type' => 'bgpage'));
    if (!$child) {
      watchdog('bgpage', "bgpage_browse() cannot load node nid '%nid'", array('%nid' => $nid), WATCHDOG_ERROR);
    }
    if ($child->status == 1) {
      $children[] = $child;
    }
  }

  if ($children) {
    $pager = theme('pager');
    $output .= $pager;
    foreach ($children as $child) {
      $child_links[] = l($child->title, "node/$child->nid/bgpage");
    }
    if (count($child_links) > 1) {
      $output .= "<div class=\"node-links\">" . implode(' | ', $child_links) . "</div>";
    }
    $output .= bgimage_stage_filter_selector($node);
    $output .= '<br />';

    foreach ($children as $child) {
      $child->comment = 0;
      $child->teaser = bgimage_representative_images($child, 0);

      // TODO: check_markup() is stripping the images out.
      // This ugly hack sets the node format to Full HTML.
      // We should Do It Right instead of doing this.
      $child->format = 2;
      $output .= node_view($child, 1);
    }
    if ($pager) {
      $output .= $pager;
    }
  } else {
    $output .= bgimage_representative_images($node, $main);
    $output .= "<br /><br />";
    $output .= bgimage_stage_filter_selector($node);
    $output .= "<br /><br /><p>There are no guide pages below this one.</p>";
  }
  return $output;
}

/**
 * Generate the taxonomic tree from the root (Arthropoda) to the current taxon.
 *
 * @param $nid
 *   The node ID of the node being viewed.
 * @param $mode
 *   If true, show all the children from this point in the taxonomic tree on
 *   down.
 */
function bgpage_tree($nid, $mode = NULL) {
  global $TAXON_NAMES, $TAXON_IDS;
  $nids = array();
  $node = node_load($nid);
  $node_wrapper = entity_metadata_wrapper('node', $node);

  // Build the array of nids to list.
  $nids = explode(',', $node_wrapper->field_parent->value());

  // Then, then node itself;
  $nids[] = $node->nid;

  // Next, the immediate children.
  $children_nids = db_query('SELECT entity_id
                              FROM {field_data_field_parent} fdfp
                              inner join {node} n on n.nid = fdfp.entity_id
                              inner join {bgpage_archive} bgpage on bgpage.nid = n.nid
                              where n.status = 1
                              and fdfp.field_parent_value like :end
                              order by bgpage.sequence, bgpage.nid', array(
                                ':end' => '%,' . $node->nid,
                              ))->fetchCol();
  $nids = array_merge($nids, $children_nids);

  // Build an array of pseudo nodes to render the tree.
  $nodes = bg_prepare_nodes($nids, 'bgpage');

  // Fetch titles.
  $result = db_query('SELECT nid, title FROM {node} WHERE nid IN (:nids)', array(':nids' => $nids));
  foreach ($result as $row) {
    $nodes[$row->nid]->title = $row->title;
  }

  // Fetch taxon and scientific name.
  $nodes = bg_field_load_multiple('field_parent', $nodes);
  $nodes = bg_field_load_multiple('field_taxon', $nodes);
  $nodes = bg_field_load_multiple('field_scientific_name', $nodes);

  return bgpage_tree_build($nodes);
}

/**
 * Builds a hierarchy tree for a set of related nodes.
 *
 * @param array $nodes
 *   An array of pseudo-nodes ordered hierarchycally. The term pseudo is
 *   used because they are not fully loaded nodes due to performance reasons.
 * @returns string
 *   The rendered HTML that represents the tree.
 */
function bgpage_tree_build($nodes) {
  global $TAXON_NAMES, $TAXON_IDS;
  $output = '<span class="graytext">Kingdom</span> <strong>Animalia</strong> - Animals<br/>';

  foreach ($nodes as $node) {
    $node_wrapper = entity_metadata_wrapper('node', $node);
    $indents = count(explode(',', $node_wrapper->field_parent->value()));
    $output .= str_repeat('&nbsp;', $indents * 2) . bgpage_tree_child($node);
  }

  return $output;
}

function bgpage_tree_children(&$all, $parent) {
  $children = $all[bgpage_get_path($parent)];
  if (!$children)
    return;

  $output .= "<div class=\"bgpage-taxon\">";
  foreach ($children as $child) {
    $output .= bgpage_tree_child($child);
    $output .= bgpage_tree_children($all, $child);
  }
  $output .= "</div>\n";
  return $output;
}

/**
 * Renders a tree element.
 *
 * @param object node
 *   A pseudo node that contains title, field_parent, field_taxon and field_scientific_name.
 * @return string
 *   The rendered tree item.
 */
function bgpage_tree_child($node) {
  global $TAXON_NAMES, $TAXON_IDS;
  if (!empty($node->field_taxon) && isset($TAXON_NAMES[$node->field_taxon[LANGUAGE_NONE][0]['value']])) {
    $taxon_name = $TAXON_NAMES[$node->field_taxon[LANGUAGE_NONE][0]['value']];
    $taxon_id = $node->field_taxon[LANGUAGE_NONE][0]['value'];
  }
  else {
    $taxon_name = t('No Taxon');
    $taxon_id = NULL;
  }

  $scientific_name = check_plain($node->title);
  if (!empty($node->field_scientific_name)) {
    $scientific_name = $node->field_scientific_name[LANGUAGE_NONE][0]['value'];
  }

  $child_count = '';
  if (!empty($node->field_parent)) {
    $search_path = $node->field_parent[LANGUAGE_NONE][0]['value'] . ','. $node->nid;
    // TODO: add caching here.
    $query = new EntityFieldQuery;
    $query->entityCondition('entity_type', 'node')
          ->entityCondition('bundle', 'bgpage')
          ->fieldCondition('field_parent', 'value', $search_path, 'CONTAINS');
    $count = $query->count()->execute();
    $child_count = ' ('. $count .')';
  }

  $output = "<span class=\"bgpage-taxon-title\">$taxon_name </span>";
  $italics = $taxon_id >= $TAXON_IDS["Genus"];
  $output .= "<span class=\"bgpage-taxon-desc\">";
  if ($italics) {
    $output .= "<i>";
  }
  $output .= l("<strong>$scientific_name</strong>", "node/" . $node->nid . "/tree", array('html' => TRUE));
  if ($italics) {
    $output .= "</i>";
  }
  if ($node->title != $scientific_name) {
    $output .= " - " . check_plain($node->title);
  }
  if (!empty($node->field_hodges_number)) {
    $output .= " - Hodges#" . $node->field_hodges_number[LANGUAGE_NONE][0]['value'];
  }
  $output .= "$child_count</span><br />\n";

  return $output;
}

