<?php

include_once 'bg.features.inc';

// Define the following constants in the guide-specific module.
// E.g., for bugguide, in bugguide.module.
// Node ID of ID Request
// define('BG_ID_REQUEST_NID', 6);

// Node ID of Frass
// define('BG_FRASS_NID', 9410);

/**
 * @file
 * The bg module provides bugguide-specific functionality.
 */

/**
 * Implementation of hook_theme().
 */
function bg_theme() {
  $module_path = drupal_get_path('module', 'bg');
  return array(
    'bg_fixup_locations_table' => array(
      'render element' => 'form',
    ),
    'bg_top_links' => array(
      'template' => 'top-links',
      'path' => $module_path . '/templates',
    ),
    'bg_visual_guide' => array(
      'template' => 'visual-guide',
      'path' => $module_path . '/templates',
    )
  );
}

/**
 * Implements hook_menu().
 */
function bg_menu() {
  $items['bg'] = array(
    'title' => 'Utilities',
    'description' => 'BugGuide system utilities',
    'page callback' => 'bg_utilities',
    'access arguments' => array('administer BG utilities'),
    'expanded' => 1,
    'file' => 'bg.admin.inc',
  );
  $items['bg/orphans'] = array(
    'title' => 'Show orphaned nodes',
    'description' => 'Shows pages, images, links, and references with no parent',
    'page callback' => 'bg_orphans',
    'access arguments' => array('administer BG utilities'),
    'file' => 'bg.admin.inc',
  );
  $items['bg/badlocations'] = array(
    'title' => 'Fix image locations that have country names in county field',
    'description' => 'Shows images that have country names in county field',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('bg_fixup_locations_form'),
    'access arguments' => array('administer BG utilities'),
    'file' => 'bg.admin.inc',
  );

  return $items;
}

/**
 * Place Forums menu exactly.
 */
function bg_menu_alter(&$items) {
  $items['forum']['weight'] = 5;
}

/**
 * Implements hook_date_formats().
 */
function bg_date_formats() {
  return array(
    array(
      'type' => 'bg_short_F_j_Y',
      'format' => 'F j, Y',
      'locales' => array(),
    ),
  );
}
/**
 * Implements hook_date_format_types().
 */
function bg_date_format_types() {
  return array(
    'bg_short_F_j_Y' => t('Short: F j, Y'),
  );
}

/**
 * Implements hook_permission().
 */
function bg_permission() {
  return array(
    'view badges' => array(
      'title' => t('View badges denoting privileged roles'),
      'description' => t('Make visible which other users have enhanced privileges.'),
    ),
    'administer bg utilities' => array(
      'title' => t('Administer bg utilities'),
      'description' => t('Perform bg maintenance tasks'),
    )
  );
}

/**
 * Implements hook_filter_info().
 */
function bg_filter_info() {
  $filters['bg_list'] = array(
    'title' => t('List item filter'),
    'description' => t('Every line that starts with a + will be converted into a list item.'),
    'process callback'  => '_bg_filter_list_item_process',
  );
  return $filters;
}

/**
 * BG list item filter process callback.
 */
function _bg_filter_list_item_process($text, $filter, $format) {
  return preg_replace('/^\+(.+)$/mi', '<div class="bgpage-bullet">$1</div>', $text);
}

/**
 * Determine if a string ends with a substring
 *
 * @param string $str
 * @param string $sub
 * @return string
 */
function bg_str_ends_with($str, $sub) {
  return substr( $str, strlen( $str ) - strlen( $sub ) ) == $sub;
}

/**
 * Build a one-line taxonomic linked breadcrumb.
 *
 * @param object $node
 *   A node.
 * @param string $guidebc
 *   Defines which format to use to render each taxon name (common, scientific or both).
 *   This is a field on the user entity which users choose by editing their profile.
 * @param integer $from
 *   If the breadcrumb should not start at Home / Guide then specify which
 *   the nid of the taxon it should start from.
 * @return array of links with title and href.
 */
function bg_create_taxonomic_breadcrumb($node, $guidebc = 'Scientific name (Common name)', $from = NULL, $json = FALSE) {
  global $TAXON_NAMES;
  global $TAXON_IDS;

  // If the node has no parent field a taxonomic breadcrumb is not sane.
  if (!isset($node->field_parent[LANGUAGE_NONE][0]['value'])) {
    return array();
  }

  $bc = array();
  if (!$from ) {
    $bc[] = l('Home', '');
  }

  if ($json) {
    $json_array = array();
  }

  $nids = array($node->nid);
  $parent_nids = explode(',', $node->field_parent[LANGUAGE_NONE][0]['value']);
  $nids = array_merge($parent_nids, $nids);

  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'bgpage')
    ->propertyCondition('nid', $nids, 'IN')
    ->fieldOrderBy('field_taxon', 'value', 'ASC');
  $result = $query->execute();
  if (isset($result['node'])) {
    $nids = array_keys($result['node']);
    $nodes = entity_load('node', $nids);

    $start_building = $from ? FALSE : TRUE;
    foreach($nodes as $parent_node) {
      if (!$start_building) {
        if ($parent_node->nid == $from) {
          $start_building = TRUE;
        }
        else {
          continue;
        }
      }

      // Common name is the node title.
      $common = $parent_node->title;

      // What level of hierarchy we're at
      if (!empty($parent_node->field_taxon) && isset($TAXON_NAMES[$parent_node->field_taxon[LANGUAGE_NONE][0]['value']])) {
        $taxon = $TAXON_NAMES[$parent_node->field_taxon[LANGUAGE_NONE][0]['value']];
      }
      else {
        $taxon = t('No Taxon');
      }

      // We only look at the format when the node has a scientific name.
      $scientific_name = !empty($parent_node->field_scientific_name) ? $parent_node->field_scientific_name[LANGUAGE_NONE][0]['value'] : '';
      if (!empty($scientific_name)) {

        // If we are building the name for the species, include Genus name in
        // breadcrumb. Don't do this for $json.
        // Do this:  ... / Muscini / Musca / Musca domestica (House Fly)
        // Not this: ... / Muscini / Musca / domestica (House Fly)
        if ($taxon == 'Species' && !$json) {
          // We are rendering, e.g., domestica and we need the Musca in Musca domestica.
          // A parent of this node has it and we already loaded it in $nodes,
          // which we are currently looping through. Peek into the scientific
          // name field of a parent in order to get the genus name and prepend.
          // Caution: do not assume that the immediate parent is a genus; see node/162470
          // Go back up the tree looking for a genus. When we find one, grab
          // the genus name.
          $reverse_nids = array_reverse($nids);
          foreach ($reverse_nids as $rnid) {
            if (!empty($nodes[$rnid]->{'field_taxon'}) &&
                isset($nodes[$rnid]->{'field_taxon'}[LANGUAGE_NONE][0]['value']) &&
                $nodes[$rnid]->{'field_taxon'}[LANGUAGE_NONE][0]['value'] == $TAXON_IDS['Genus']) {
              // Found a genus.
              $scientific_name = $nodes[$rnid]->{'field_scientific_name'}[LANGUAGE_NONE][0]['value'] . ' ' . $scientific_name;
            }
          }
        }

        if ($guidebc == 'Scientific name') {
          $linktext = $scientific_name;
        }
        else if ($guidebc == 'Common name') {
          $linktext = $common;
        }
        else if ($guidebc == 'Scientific name (Common name)') {
          if ($scientific_name == $common) {
            // "Musca", not "Musca (Musca)"
            $linktext = $scientific_name;
          }
          else {
            $linktext = $scientific_name . ' (' . $common . ')';
          }
        }
        else {
          // Common name (Scientific name)
          if ($scientific_name == $common) {
            // "Musca", not "Musca (Musca)"
            $linktext = $common;
          }
          else {
            $linktext = $common . ' (' . $scientific_name . ')';
          }
        }
      }
      else {
        $linktext = $common;
      }
      if ($json) {
        $json_array[$taxon] = empty($scientific_name) ? $common : $scientific_name;
      }
      else {
        $bc[] = l($linktext, 'node/' . $parent_node->nid);
      }
    }
  }

  return $json ? $json_array : $bc;
}

/**
 * Implements hook_preprocess_page().
 *
 * @see bgpage_menu_local_tasks_alter()
 */
function bg_preprocess_page(&$vars) {
  global $user;

  // Don't change the path in administrative pages.
  if (path_is_admin(current_path())) {
    return;
  }

  // Check that we have an nid in the path.
  $nid = arg(1);
  if (arg(0) == 'node' && is_numeric($nid)) {
    $node = node_load($nid);

    // Eliminate local task tabs on these special pages or their children.
    $pid = bg_get_first_parent_nid($node);
    if (($nid == BG_ID_REQUEST_NID) || // ID Request
        ($nid == BG_FRASS_NID) ||      // Frass
        ($pid == BG_ID_REQUEST_NID) || // Image in ID Request
        ($pid == BG_FRASS_NID) ||      // Image in Frass
        $vars['is_front']              // Front page
        ) {
      $keep = array();
      foreach ($vars['tabs']['#primary'] as $item) {
        if ($item['#link']['path'] == 'node/%/edit') {
          $keep[] = $item;
        }
        elseif ($item['#link']['path'] == 'node/%/view') {
          $item['#link']['title'] = t('View');
          $keep[] = $item;
        }
      }
      $vars['tabs']['#primary'] = array();
      foreach ($keep as $item) {
        $vars['tabs']['#primary'][] = $item;
      }
    }

    // Set breadcrumb for bgpage, bgimage and book reference nodes.
    if (!empty($node) && isset($node->type) && in_array($node->type, array('bgpage', 'bgimage', 'bglink', 'book_reference'))) {
      if ($node->type == 'bgimage') {
        // For bgimage nodes we load the bgpage parent. For example, if we are
        // looking at an image whose parent is House Fly (Musca domestica) that
        // is what we use for the end of the breadcrumb trail.
        $parent_nid = bg_get_parent_nid($node);

        // Fast breadcrumb building for images in ID Request and Frass.
        if ($parent_nid == BG_ID_REQUEST_NID) {
          drupal_set_breadcrumb(array(l('Home', ''), l('ID Request', 'node/' . BG_ID_REQUEST_NID . '/bgimage')));
          return;
        }
        elseif ($parent_nid == BG_FRASS_NID) {
          drupal_set_breadcrumb(array(l('Home', ''), l('Frass', 'node/' . BG_FRASS_NID . '/bgimage')));
          return;
        }
        else {
          $node = node_load($parent_nid);
          if (empty($node)) {
            return;
          }
        }
      }
      // Adjust the format of each crumb to respect user pref if user is logged in.
      if (user_is_logged_in()) {
        $account = user_load($user->uid);
        $guidebc = isset($account->field_user_breadcrumb_format[LANGUAGE_NONE][0]['value']) ? $account->field_user_breadcrumb_format[LANGUAGE_NONE][0]['value'] : 'Scientific name (Common name)';
        $breadcrumbs = bg_create_taxonomic_breadcrumb($node, $guidebc);
      }
      else {
        $breadcrumbs = bg_create_taxonomic_breadcrumb($node);
      }
      drupal_set_breadcrumb($breadcrumbs);
    }
  }
}

/**
 * Builds an array of entities to use on field_attach_load.
 *
 * @param array $nids
 *   An array of node nids.
 * @param string type
 *   The content type of the nids.
 * @return array
 *   An array of entities ready to be used for field_attach_load().
 */
function bg_prepare_nodes($nids, $type) {
  $entities = array();
  foreach ($nids as $nid) {
    $entities[$nid] = (object) array(
      'type' => $type,
      'nid' => $nid,
      'vid' => NULL,
    );
  }
  return $entities;
}


/**
 * Fetches a field for an array of entities.
 *
 * @param string $field
 *   The field name to fetch such as field_taxon.
 * @param array $nids
 *   The list of nids to fetch the data for.
 * @return
 *   array of stdClass objects.
 */
function bg_field_load_multiple($field, $entities) {
  if (count($entities)) {
    $result = db_query('select entity_id as nid, ' . $field . '_value as value from {field_data_' . $field . '} where entity_id in (:nids)', array(
      ':nids' => array_keys($entities),
    ));
    foreach ($result as $row) {
      $entities[$row->nid]->{$field}[LANGUAGE_NONE][0]['value'] = $row->value;
    }
  }
  return $entities;
}

/**
 * Returns a node's immediate parent nid.
 * Given 3,878075,52,60,40606,1117170,40619,144,377483 return 377483
 *
 * @param object @node
 * @return mixed
 *   int when there is a parent nid.
 *   NULL when there is no parent nid.
 */
function bg_get_parent_nid($node) {
  $nid = NULL;
  if (isset($node->field_parent) && !empty($node->field_parent[LANGUAGE_NONE])) {
    $parents = explode(',', $node->field_parent[LANGUAGE_NONE][0]['value']);
    $nid = end($parents);
  }
  return $nid;
}

/**
 * Returns a node's first parent nid.
 * Given 3,878075,52,60,40606,1117170,40619,144,377483 return 3
 *
 * @param object @node
 * @return mixed
 *   int when there is a parent nid.
 *   NULL when there is no parent nid.
 */
function bg_get_first_parent_nid($node) {
  $nid = NULL;
  if (isset($node->field_parent) && !empty($node->field_parent[LANGUAGE_NONE])) {
    $parents = explode(',', $node->field_parent[LANGUAGE_NONE][0]['value']);
    $reverse = array_reverse($parents);
    $nid = end($reverse);
  }
  return $nid;
}

/**
 * Implements hook_node_view_alter().
 */
function bg_node_view_alter(&$build) {
  // Check if we need to process citations of type [cite:123].
  if (($build['#view_mode'] != 'full') || !isset($build['bgpage_citations'])) {
    return;
  }

  // Loop all fields and search for citation tokens.
  // These are not Drupal tokens and that is why they are processed here.
  $citation_nids = array();
  foreach ($build as $field_key => $field) {
    if (strpos('#', $field_key) === 0) {
      continue;
    }
    if (is_array($field) && !empty($field[0]['#markup'])) {
      $text = $field[0]['#markup'];
      unset($match);
      if (preg_match_all("/\[cite(all)?:(\d+)(,(\d+))?(,(\d+))?\]/i", $text, $match)) {
        $find = array();
        $replace = array();
        // Loop citation matches and replace them by links of type "Some reference(2)".
        foreach ($match[2] as $idx => $nid) {
          $find[] = $match[0][$idx];
          if (!in_array($nid, $citation_nids)) {
            $citation_nids[] = $nid;
          }

          // Extract citation index so we can show it as "(7)" in the text.
          $citation_index = array_search($nid, $citation_nids);

          $replace[] = '<span class="bgpage-citation">(' . l($citation_index + 1, 'node/' . $nid) . ')</span>';
        }
        $build[$field_key][0]['#markup'] = str_replace($find, $replace, $text);
      }
    }
  }

  // List citations at field bgpge_citations.
  if (count($citation_nids)) {
    $list_items = '<ol>';
    $cited_nodes = node_load_multiple($citation_nids);
    foreach ($cited_nodes as $bgref_node) {
      if (!empty($bgref_node)) {
        $list_items .= '<li>' . l($bgref_node->title, 'node/' . $bgref_node->nid);
        // Append book details if they are available.
        $book_details = array();
        if (!empty($bgref_node->field_book_reference_author['und'][0])) {
          $book_details[] = $bgref_node->field_book_reference_author['und'][0]['safe_value'];
        }
        if (!empty($bgref_node->field_book_reference_year['und'][0])) {
          $book_details[] = $bgref_node->field_book_reference_year['und'][0]['value'];
        }
        if (!empty($bgref_node->field_book_reference_publisher['und'][0])) {
          $book_details[] = $bgref_node->field_book_reference_publisher['und'][0]['safe_value'];
        }
        if (count($book_details)) {
          $list_items .= '</br>' . implode('. ', $book_details) . '.';
        }
        $list_items .= '</li>';
      }
    }
    $list_items .= '</ol>';
    $build['bgpage_citations'][0]['#markup'] = $list_items;
  }
  else {
    unset($build['bgpage_citations']);
  }
}

/**
 * Implements hook_entity_info_alter().
 */
function bg_entity_info_alter(&$entity_info) {
  $entity_info['node']['view modes']['homepage'] = array(
    'label' => t('Homepage'),
    'custom settings' => TRUE,
  );
}

/**
 * Honor bg_disable_email setting in settings.php.
 */
function bg_mail_alter(&$message) {
  if (variable_get('bg_disable_email', FALSE)) {
    $message['send'] = FALSE;
  }
}

function bg_block_info() {
  $blocks['bg_top_links'] = array(
    'info' => t('Top links'),
    'cache' => DRUPAL_CACHE_PER_ROLE,
    'status' => TRUE,
    'region' => 'brand',
  );
  $blocks['bg_visual_guide'] = array(
    'info' => t('Visual Guide'),
    'cache' => DRUPAL_CACHE_PER_ROLE,
    'status' => TRUE,
    'region' => 'content',
    'weight' => 1,
    
  );

  return $blocks;
}

function bg_block_view($delta = ''){
  $block = array();

  switch($delta){
    case 'bg_top_links':
      $block['content'] = theme('bg_top_links');
      break;
    case 'bg_visual_guide':
      $block['content'] = theme('bg_visual_guide');
      break;
  }

  return $block;
}

