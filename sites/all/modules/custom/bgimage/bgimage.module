<?php
/**
 * @file
 * Code for the BG Image feature.
 */

include_once 'bgimage.features.inc';
include_once './images/image_obfuscate.inc';

/**
 * Implementation of hook_theme().
 */
function bgimage_theme() {
  $module_path = drupal_get_path('module', 'bgimage');
  return array(
    'views_view__featured_image__block' => array(
      'variables' => array('view' => NULL, 'options' => NULL, 'row' => NULL),
      'template' => 'views-view--featured-image--block',
      'base hook' => 'views_view',
      'path' => $module_path . '/templates',
    )
  );
}

/**
 * Implements hook_menu_alter().
 */
function bgimage_menu_alter(&$items) {
  $items['node/%node/clone/%clone_token']['title callback'] = '_bgimage_clone_action_link_title';
}

/**
 * Same as in bootstrap.inc but with no path requirements. Directly callable.
 */
function bgimage_fast_404() {
  drupal_add_http_header('Status', '404 Not Found');
  $fast_404_html = variable_get('404_fast_html', '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML+RDFa 1.0//EN" "http://www.w3.org/MarkUp/DTD/xhtml-rdfa-1.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>404 Not Found</title></head><body><h1>Not Found</h1><p>The requested URL "@path" was not found on this server.</p></body></html>');
  // Replace @path in the variable with the page path.
  print strtr($fast_404_html, array('@path' => check_plain(request_uri())));
  exit;
}

/**
 * Implements hook_menu().
 */
function bgimage_menu() {
  $items = array();

  $items['bgimage/clip/%node'] = array(
    'title' => 'Adds an image to the Clipboard',
    'page callback' => 'bgimage_clip',
    'page arguments' => array(2),
    'access arguments' => array('use image clipboard'),
    'type' => MENU_CALLBACK,
    'file' => 'bgimage.pages.inc',
  );

  $items['bgimage/unclip/%node'] = array(
    'title' => 'Removes an image from the clipboard',
    'page callback' => 'bgimage_unclip',
    'page arguments' => array(2),
    'access arguments' => array('use image clipboard'),
    'type' => MENU_CALLBACK,
    'file' => 'bgimage.pages.inc',
  );

  $items['bgimage/move/%node'] = array(
    'title' => 'Moves images in the clipboard to the current page',
    'page callback' => 'bgimage_move_clipped',
    'page arguments' => array(2),
    'access arguments' => array('use image clipboard'),
    'type' => MENU_CALLBACK,
    'file' => 'bgimage.pages.inc',
  );

  $items['bgimage/quiet_move/%node'] = array(
    'title' => 'Quietly moves images in the clipboard to the current page',
    'page callback' => 'bgimage_move_clipped',
    'page arguments' => array(2, true),
    'access arguments' => array('quiet move all bgimages'),
    'type' => MENU_CALLBACK,
    'file' => 'bgimage.pages.inc',
  );

  $items['bgimage/link'] = array(
    'title' => 'Links images on the clipboard',
    'page callback' => 'bgimage_link_clipped',
    'access arguments' => array('use image clipboard'),
    'type' => MENU_CALLBACK,
    'file' => 'bgimage.pages.inc',
  );

  $items['bgimage/unlink'] = array(
    'title' => 'Unlinks a series of images',
    'page callback' => 'bgimage_unlink_image_series',
    'page arguments' => array(2),
    'access arguments' => array('use image clipboard'),
    'type' => MENU_CALLBACK,
    'file' => 'bgimage.pages.inc',
  );

  $items['bgimage/unclip_all'] = array(
    'title' => 'Removes images from the Clipboard',
    'page callback' => 'bgimage_unclip_all',
    'access arguments' => array('use image clipboard'),
    'type' => MENU_CALLBACK,
    'file' => 'bgimage.pages.inc',
  );

  $items['bgimage/stage'] = array(
    'title' => 'Set stage',
    'page callback' => 'bgimage_set_stage',
    'page arguments' => (array(2)),
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );

  $items['node/%bgpage_node/bgimage/add'] = array(
    'title' => 'Add image',
    'page callback' => 'bgimage_add_image',
    'page arguments' => array(1),
    'access arguments' => array('create bgimages'),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'bgimage.pages.inc',
  );

  $items['node/%bgpage_node/bgimage/recent'] = array(
    'title' => 'Recent images',
    'page callback' => 'bgimage_recent',
    'page arguments' => array(1),
    'access arguments' => array('access content'),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'bgimage.pages.inc',
  );

  $items['images/raw/%/%/%'] = array(
    'page arguments' => array(4),
    'type' => MENU_CALLBACK,
    'access arguments' => array('access content'),
    'page callback' => 'bgimage_redirect_raw',
  );

  return $items;
}

/**
 * Redirect legacy raw URLs to current paths.
 */
function bgimage_redirect_raw($path) {
  // ABCDEFGHIJ.jpg
  $s = explode('.', $path);
  if (isset($s[1]) && $s[1] == 'jpg') {
    $hash = image_deobfuscate($s[0]);
    if (strlen($hash) <= 32) {
      bgimage_fast_404();
    }
    $nid = substr($hash, 32);
    // TODO add index to avoid table scan.
    $fid = db_query("
      SELECT f.fid
      FROM file_usage f
          LEFT JOIN field_data_field_bgimage_base b
              ON b.entity_id = f.id
      WHERE b.entity_id = :nid", array(':nid' => $nid))->fetchField();
    if ($fid) {
      $file = file_load($fid);
      drupal_goto(file_create_url($file->uri));
    }
  }
  // Improper path or no matching uuid.
  bgimage_fast_404();
}

/**
 * Implements hook_permission().
 */
function bgimage_permission() {
  return array(
    'create bgimages' => array(
      'title' => 'Create bgimage nodes',
    ),
    'view fullsize bgimages' => array(
      'title' => 'View full size images',
    ),
    'use image clipboard' => array(
      'title' => 'Use image clipboard',
    ),
    'move all bgimages' => array(
      'title' => 'Move all bgimages',
    ),
    'quiet move all bgimages' => array(
      'title' => 'Quiet move all bgimages',
    ),
    'link all bgimages' => array(
      'title' => 'Link bgimage nodes',
    ),
  );
}

/**
 * Implements hook_apachesolr_index_document_build_node().
 */
function bgimage_apachesolr_index_document_build_node($document, $entity, $env_id) {
  if ($entity->type !== 'bgimage') {
    return;
  }

  // Internal image's identifier (so authors can search and find their images).
  if (!empty($entity->field_bgimage_id[LANGUAGE_NONE][0]['value'])) {
    $document->addField('ts_field_bgimage_id', $entity->field_bgimage_id[LANGUAGE_NONE][0]['value']);
  }

  // Parents field used for searching for descendants.
  $parents = array();
  if (!empty($entity->field_parent[LANGUAGE_NONE][0]['value'])) {
    $parents = explode(',', $entity->field_parent[LANGUAGE_NONE][0]['value']);
  }
  foreach ($parents as $parent) {
    $document->addField('sm_bgimage_parents', $parent);
  }

  // Immediate parent's nid and title used for grouping results.
  $parent_nid = bg_get_parent_nid($entity);
  if ($parent_nid != NULL) {
    $parent_node = node_load($parent_nid);
    if (!empty($parent_node)) {
      $document->addField('is_bgimage_immediate_parent', $parent_nid);
      $document->addField('ss_bgimage_immediate_parent_title', $parent_node->title);
    }
  }

  // List of parents as links (doesn't include the current image node). Used at the Images tab.
  $breadcrumbs = bg_create_taxonomic_breadcrumb($entity, 'Scientific name');
  foreach ($breadcrumbs as $breadcrumb) {
    $document->addField('sm_bgimage_breadcrumbs', $breadcrumb);
  }

  // Classification field used for sorting.
  $classification = '';
  if (!empty($entity->field_parent[LANGUAGE_NONE][0]['value'])) {
    $document->addField('ss_bgimage_classification', $entity->field_parent[LANGUAGE_NONE][0]['value']);
  }

  // Image thumbnail.
  $node_wrapper = entity_metadata_wrapper('node', $entity);
  $field_bgimage = $node_wrapper->field_bgimage_image->value();
  if (!empty($field_bgimage)) {
    $image_properties = array(
      'style_name' => 'bg_small',
      'path' => $field_bgimage['uri'],
      'alt' => $node_wrapper->title->value(array('sanitize' => TRUE)),
      'title' => $node_wrapper->title->value(array('sanitize' => TRUE)),
      'attributes' => array('style' => 'margin: 10px;'),
    );
    $image = theme('image_style', $image_properties);
    $link = '<a href="' . url('node/' . $entity->nid) . '" title="' . $node_wrapper->title->value(array('sanitize' => TRUE)) . '">' . $image . '</a>';
    $document->addField('ss_bgimage_thumbnail', $link);
  }

  // Rating field used for sorting.
  $rating_avg = 0;
  $rating_count = 0;
  // Rating cannot be accessed through an EMW :-(
  if (!empty($entity->field_bgimage_representative[LANGUAGE_NONE][0])) {
    $rating_avg = $entity->field_bgimage_representative[LANGUAGE_NONE][0]['average'];
    $rating_count = $entity->field_bgimage_representative[LANGUAGE_NONE][0]['count'];
  }
  $document->addField('is_bgimage_rating_avg', $rating_avg);
  $document->addField('is_bgimage_rating_count', $rating_count);
}

/**
 * Implements hook_apachesolr_field_name_map_alter().
 */
function bgimage_apachesolr_field_name_map_alter(&$map) {
  $map['ts_field_bgimage_id'] = t('Image ID (used by authors for private tagging)');
}

/**
 * Implements hook_ds_fields_info().
 */
function bgimage_ds_fields_info($entity_type) {
  $fields = array();

  if ($entity_type == 'node') {
    $fields['bgimage_clip'] = array(
      'title' => t('Add to clipboard'),
      'description' => t('Adds an image to the clipboard.'),
      'field_type' => DS_FIELD_TYPE_FUNCTION,
      'function' => '_bgimage_field_clip',
      'file' => drupal_get_path('module', 'bgimage') . '/bgimage.ds.field.inc',
    );

    $fields['bgimage_photo_number'] = array(
      'title' => t('Photo number'),
      'description' => t('Renders photo number as Photo #123456.'),
      'field_type' => DS_FIELD_TYPE_FUNCTION,
      'function' => '_bgimage_field_photo_number',
      'file' => drupal_get_path('module', 'bgimage') . '/bgimage.ds.field.inc',
    );

    $fields['bgimage_copyright'] = array(
      'title' => t('Photo copyright'),
      'description' => t('Renders a copyright statement.'),
      'field_type' => DS_FIELD_TYPE_FUNCTION,
      'function' => '_bgimage_field_copyright',
      'file' => drupal_get_path('module', 'bgimage') . '/bgimage.ds.field.inc',
    );

    $fields['bgimage_related'] = array(
      'title' => t('Related images'),
      'description' => t('Renders related images for an specimen.'),
      'field_type' => DS_FIELD_TYPE_FUNCTION,
      'function' => '_bgimage_field_related_images',
      'file' => drupal_get_path('module', 'bgimage') . '/bgimage.ds.field.inc',
    );

    $fields['bgimage_title_classification'] = array(
      'title' => t('Title and classification'),
      'description' => t('Renders the title and classification of an image.'),
      'field_type' => DS_FIELD_TYPE_FUNCTION,
      'function' => '_bgimage_field_title_classification',
      'file' => drupal_get_path('module', 'bgimage') . '/bgimage.ds.field.inc',
    );

    $fields['bgimage_field_placed_by'] = array(
      'title' => t('Placed by'),
      'description' => t('Shows who uploaded an image.'),
      'field_type' => DS_FIELD_TYPE_FUNCTION,
      'function' => '_bgimage_field_placed_by',
      'file' => drupal_get_path('module', 'bgimage') . '/bgimage.ds.field.inc',
    );

    $fields['bgimage_field_taxonomy_path'] = array(
      'title' => t('Taxonomy path'),
      'description' => t('Renders a list of taxonomy links for this image.'),
      'field_type' => DS_FIELD_TYPE_FUNCTION,
      'function' => '_bgimage_field_taxonomy_path',
      'file' => drupal_get_path('module', 'bgimage') . '/bgimage.ds.field.inc',
    );

    $fields['location_combined'] = array(
      'title' => t('Location'),
      'description' => t('Combine the location fields'),
      'field_type' => DS_FIELD_TYPE_FUNCTION,
      'function' => '_bgimage_field_location_combined',
      'file' => drupal_get_path('module', 'bgimage') . '/bgimage.ds.field.inc',
    );

    return array($entity_type => $fields);
  }
  return;
}

/**
 * Implements hook_field_formatter_info().
 */
function bgimage_field_formatter_info() {
  $formatters = array(
    'bgimage_conditional_link_formatter' => array(
      'label' => t('Image Conditional Link'),
      'field types' => array('image'),
      'settings' => array('image_style' => 'bg_large', 'image_link' => ''),
    ),
  );

  return $formatters;
}

/**
 * Implements hook_field_formatter_view().
 */
function bgimage_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();
  // Check if the formatter involves a link.
  if ($display['settings']['image_link'] == 'content') {
    $uri = entity_uri($entity_type, $entity);
  }
  elseif ($entity->type == 'bgimage' && count($items) == 1) {
    // Provide a link to the fullsize image if either the user created the image
    // or they have the right permission.
    global $user;
    if ($items[0]['uid'] == $user->uid || user_access('view fullsize bgimages')) {
      $uri = array(
        'path' => file_create_url($items[0]['uri']),
        'options' => array(),
      );
    }
  }

  foreach ($items as $delta => $item) {
    $element[$delta] = array(
      '#theme' => 'image_formatter',
      '#item' => $item,
      '#image_style' => $display['settings']['image_style'],
      '#path' => isset($uri) ? $uri : '',
    );
  }

  return $element;
}

/**
 * Implements hook_field_formatter_settings_form() by wrapping the default.
 */
function bgimage_field_formatter_settings_form($field, $instance, $view_mode, $form, &$form_state) {
  return image_field_formatter_settings_form($field, $instance, $view_mode, $form,$form_state);
}

/**
 * Implements hook_field_formatter_settings_summary() by wrapping the default.
 */
function bgimage_field_formatter_settings_summary($field, $instance, $view_mode) {
  return image_field_formatter_settings_summary($field, $instance, $view_mode);
}

/**
 * Implements hook_node_validate().
 */
function bgimage_node_validate($node, $form, &$form_state) {
  if ($node->type != 'bgimage') {
    return;
  }

  drupal_load('module', 'bg');

  // Attempt to set the full parent based on our calling nid.
  bg_node_validate_set_parent($form_state, arg(3));

  if ($node->{'field_bgimage_image'}[LANGUAGE_NONE][0]['fid'] == 0) {
    form_set_error('field_bgimage_image', 'Did you forget to attach an image? Please attach one and resubmit.');
  }
  elseif (isset($form_state['complete form']['field_bgimage_image'][LANGUAGE_NONE][0]['#file']->uri) &&
    substr($form_state['complete form']['field_bgimage_image'][LANGUAGE_NONE][0]['#file']->uri, 0, 13) != 'public://raw/') {
    // A new image is being uploaded: we need to create a new base so that
    // the new image gets a new uri so that the browser doesn't load an image
    // at the old uri from cache instead of loading the new image.
    $form_state['values']['field_bgimage_base'][LANGUAGE_NONE][0]['value'] = bgimage_generate_uuid();
  }

  if (strtotime($form_state['values']['field_bgimage_date'][LANGUAGE_NONE][0]['value']) > time()) {
    form_set_error('field_bgimage_date', 'The date taken cannot be in the future.');
  }

  //if ((strstr($node->parent, ",57,") && !$node->immature && !$node->adult)) {
	//  $error["leps_stage"] = theme("theme_error", "Please check adult (moth/butterfly) and/or immature (egg/caterpillar/pupa) when submitting to Lepidoptera.");
  //}

  $county = isset($node->{'field_bgimage_county'}[LANGUAGE_NONE][0]['value']) ? $node->{'field_bgimage_county'}[LANGUAGE_NONE][0]['value'] : '';
  if (bg_str_ends_with(strtoupper($county), ' PARISH')) {
     $node->{'field_bgimage_county'}[LANGUAGE_NONE][0]['value'] = substr($county, 0, strlen($county) - 7);
  }
  if (bg_str_ends_with(strtoupper($county), ' COUNTY')) {
     $node->{'field_bgimage_county'}[LANGUAGE_NONE][0]['value'] = substr($county, 0, strlen($county) - 7);
  }
  if (bg_str_ends_with(strtoupper($county), ' CO')) {
     $node->{'field_bgimage_county'}[LANGUAGE_NONE][0]['value'] = substr($county, 0, strlen($county) - 3);
  }
  if (bg_str_ends_with(strtoupper($county), ' CO.')) {
     $node->{'field_bgimage_county'}[LANGUAGE_NONE][0]['value'] = substr($county, 0, strlen($county) - 4);
  }
  if ((strtoupper($county) == 'USA') ||
		(strtoupper($county) == 'UNITED STATES') ||
		(strtoupper($county) == 'CANADA')) {
		form_set_error('field_bgimage_county', 'You have entered a country here. Please specify the county/parish/district/region instead.');
	}

	// TODO
	// bgimage_set_titles()
}

/**
 * Implements hook_node_insert().
 */
function bgimage_node_insert($node) {
  if ($node->type != 'bgimage') {
    return;
  }

  _bgimage_obfuscate_uploaded_image($node);

  // Mirror information to bgimage table for scalability.
  // Note that we are inside node_save()'s database transaction.
  $fields = _bgimage_prepare($node);
  $result = db_insert('bgimage')
    ->fields($fields)
    ->execute();

  // Update bgimage_series table used for rendering related images.
  if (isset($node->original_nid)) {
    $result = db_query('select * from {bgimage_series} where nid = :nid', array(
      ':nid' => $node->original_nid,
    ))->fetchObject();
    
    // The bgimage_series table is only used if there is more than one image.
    // If this is the second image initialize the series.
    if (!$result) {
      db_insert('bgimage_series')
        ->fields(array(
          'nid' => $node->original_nid,
          'weight' => 0,
          'series' => $node->original_nid,
        ))
        ->execute();
    }
    $max_weight = db_query('SELECT MAX(weight) FROM {bgimage_series} WHERE series = :nid', array(
      ':nid' => $node->original_nid,
    ))->fetchField();
    
    // Add the new image at the end of the series.
    db_insert('bgimage_series')
      ->fields(array(
        'nid' => $node->nid,
        'weight' => $max_weight + 1,
        'series' => $node->original_nid,
      ))
      ->execute();
  }
}

/**
 * Implements hook_node_update().
 */
function bgimage_node_update($node) {
  if ($node->type != 'bgimage') {
    return;
  }

  _bgimage_obfuscate_uploaded_image($node);

  // Mirror information to bgimage table for scalability.
  // Note that we are inside node_save()'s database transaction.
  $fields = _bgimage_prepare($node);
  $result = db_update('bgimage')
    ->fields($fields)
    ->condition('nid', $node->nid)
    ->execute();
}

/**
 * Implements hook_node_delete().
 */
function bgimage_node_delete($node) {
  if ($node->type != 'bgimage') {
    return;
  }

  // Note that we are inside node_delete()'s database transaction.

  // Delete row from bgimage table.
  db_delete('bgimage')
    ->condition('nid', $node->nid)
    ->execute();

  // Update the series table if needed.
  $deleted_nid = $node->nid;
  $result = db_query('SELECT weight, series FROM {bgimage_series} WHERE nid = :nid', array(':nid' => $deleted_nid))->fetchAssoc();
  if (!$result) {
    return;
  }

  $series_base = $result['series'];
  $deleted_weight = $result['weight'];
  $series_nodes = db_query('SELECT nid, weight FROM {bgimage_series} WHERE series = :series', array(':series' => $series_base))->fetchAllAssoc('weight', PDO::FETCH_ASSOC);
  if (count($series_nodes) <= 2) {
    // There are only two images in the series and we're deleting one, so the
    // series record should be removed.
    db_delete('bgimage_series')
      ->condition('series', $series_base)
      ->execute();
    return;
  }

  // If the node we're deleting is the base of the series, then we'll need to
  // set a new series base on every node in the series.
  $series_base = $series_base == $deleted_nid ? $series_nodes['1']['nid'] : $series_base;
  foreach ($series_nodes as $series_node) {
    if ($series_node['weight'] <= $deleted_weight) {
      continue;
    }
    db_update('bgimage_series')
      ->fields(array('series' => $series_base, 'weight' => $series_node['weight'] - 1))
      ->condition('nid', $series_node['nid'])
      ->execute();
  }

  db_delete('bgimage_series')
    ->condition('nid', $deleted_nid)
    ->execute();
}

/**
 * Implements hook_filter_info().
 */
function bgimage_filter_info() {
  $filters['bg_thumb'] = array(
    'title' => t('Image thumb filter'),
    'description' => t('Changes the [:thumb] pseudo-BBCode tag into an image thumbnail.'),
    'process callback'  => '_bgimage_filter_thumb_process',
  );
  return $filters;
}

/**
 * [:thumb] filter callback.
 *
 * @param text $text
 * @return filtered text.
 */
function _bgimage_filter_thumb_process($text, $filter, $format) {
  // Extract all the nids referenced by [thumb:124], [thumb:83], etc.
  if (preg_match_all("/\[thumb:(\d+)\]/i", $text, $matches)) {
    $nids = $matches[1];
    
    // In $map, nid is the key and match occurrence number is the value.
    // Thus we have keys of every match:
    // array( 83 => 2, 124 => 1, ...)
    $map = array_flip($matches[1]);
    
    // Retrieve information about each nid.
    $result = db_query('SELECT n.nid, n.title, i.base
                        FROM {node} n, {bgimage} i
                        WHERE i.nid = n.nid AND n.nid IN (:nids)', array(':nids' => $nids));
    $expanded = array();
    $img = array();
    foreach ($result as $img) {
      // $n is the occurrence number
      $n = $map[$img->nid];
      $obfuscate = image_obfuscate($img->base . $img->nid);
      $prefix = bgimage_get_prefix($obfuscate);
      $uri = 'public://raw/' . $prefix . $obfuscate  .'.jpg';
      $rendered_image = theme('image_style', array('path' => $uri, 'style_name' => 'bg_small'));
      $expanded[$n] = '<a href="' . url('node/' . $img->nid) . '" title="' . check_plain($img->title) . '">' . $rendered_image  . '</a>';
    }

    // Create two arrays, $search and $replace, with corresponding
    // positional elements.
    foreach ($matches[1] as $key => $value) {
      //        [thumb:144595]
      $search[] = $matches[0][$key];
      //        <img src="https://bugguide.net/files/styles/bg_small/public/0L3/H0L/0L3H0LDHXL8RHZOZFL4L6ZQLPZLL6ZKL6Z8HVH5HVHZL6ZQLDHUHYH8LBZML1Z2HFH9HFHXLUZ6HFH9HZRNHRRGL9ZEHVHKL.jpg" alt="" />
      if (isset($expanded[$key])) {
        $replace[] = $expanded[$key];
      }
      else {
        // [thumb:55] references nid 55 but nid 55 was deleted.
        // Leave a hint in markup. TODO: make this survive later text filters.
        $replace[] = '<!--image ' . $value . ' deleted-->';
      }
    }
    $text = str_replace($search, $replace, $text);
  }
  return $text;
}

/**
 * Get a rendered thumbnail image.
 *
 * Example of a thumbnail image:
 * <img src="http://./files/styles/bg_small/public/108/K10/108K10LKZS3ROQHQYQY0BQY05Q10PQ9K5QC04QWKLK102QO04QA0LKB04QUKRKD00KDKWQVK9QB0UQB0GQF04QC05QC0.jpg?itok=QTeqhGF8" alt="" />
 *
 * @param stdclass $node
 *   The node object.
 *
 * @return string
 *   The rendered thumbnail image.
 *
 * @throws Exception
 */
function bgimage_thumb($node) {
  // e.g., for $node->nid = 1877
  // $base = 665891889baf9ad4d0cb1626a5f56fb5
  $base = $node->field_bgimage_base[LANGUAGE_NONE][0]['value'];

  // This is what legacy BugGuide used, before image styles:
  // $obfuscate = image_obfuscate($base . $node->nid . "?l=125");
  $obfuscate = image_obfuscate($base . $node->nid);
  $prefix = bgimage_get_prefix($obfuscate);
  // $uri = public://raw/MZA/LMZ/MZALMZWLLZELSRWLFL9LKRJZLZ6LYL9LRZJZHZ9L0R3Z3LDZGRTLERDLHZCLHZULXZ9LFLWLFL.jpg
  $uri = 'public://raw/' . $prefix . $obfuscate  .'.jpg';
  // <img src="http://./files/styles/bg_small/public/108/K10/108K10LKZS3ROQHQYQY0BQY05Q10PQ9K5QC04QWKLK102QO04QA0LKB04QUKRKD00KDKWQVK9QB0UQB0GQF04QC05QC0.jpg?itok=QTeqhGF8" alt="" />
  return theme('image_style', array(
    'path' => $uri,
    'style_name' => 'bg_small',
    'alt' => $node->title,
    'title' => $node->title,
  ));
}

/**
 * Get a thumbnail linkable image of node.
 *
 * @param stdclass $node
 *   The node object.
 * @return string
 *   A link with image as thumbnail else empty.
 */
function bgimage_thumb_link($node) {
  if (!$node) {
    return '';
  }
  return l(bgimage_thumb($node), 'node/' . $node->nid, array(
    'html' => TRUE,
    'attributes' => array(
      'title' => $node->title,
    ),
  ));
}

/**
 * Implements hook_field_widget_form_alter().
 */
function bgimage_preprocess_image_widget(&$variables) {
  if ($variables['element']['#field_name'] == 'field_bgimage_image') {
    // The filename that is shown is not the user's filename but rather our long
    // random string filename, so don't show it.
    $variables['element']['filename']['#access'] = FALSE;

    $variables['element']['upload_button']['#value'] = t('Extract image data');

    // Only show the upload button when the user has selected a file.
    $variables['element']['upload_button']['#states'] = array(
      'visible' => array(
        ':input[name="files[field_bgimage_image_und_0]"]' => array(
          '!value' => ''
        )
      )
    );
  }
}

/**
 * Generate a unique hash.
 *
 * @return string
 *   A string that will be placed in the field_data_field_bgimage_base field
 *   and the bgimage.base field. 
 */
function bgimage_generate_uuid() {
  $unique_base_created = FALSE;
  while (!$unique_base_created) {
    $uuid = md5(drupal_random_bytes(32));
    $already_exists = db_query("SELECT field_bgimage_base_value FROM {field_data_field_bgimage_base} WHERE field_bgimage_base_value = :uuid", array(':uuid' => $uuid))->fetchField();
    if ($already_exists) {
      watchdog('image', 'md5 hash collision, regenerating (' . $uuid . ')');      
    }
    else {
      $unique_base_created = TRUE;  
    }
  }
  return $uuid;
}

/**
 * Obfuscates an uploaded image for a bgimage node.
 *
 * @param object @node
 */
function _bgimage_obfuscate_uploaded_image(&$node) {
  // Even though the image field is required, during migration it may not be
  // present.
  if (isset($node->field_bgimage_image[LANGUAGE_NONE])) {
    $obfuscate = image_obfuscate($node->{'field_bgimage_base'}[LANGUAGE_NONE][0]['value'] . $node->nid);
    $prefix = bgimage_get_prefix($obfuscate);
    $directory = 'public://raw/' . $prefix;
    if (!file_prepare_directory($directory, FILE_CREATE_DIRECTORY | FILE_MODIFY_PERMISSIONS)) {
      watchdog('image', 'Failed to create style directory: %directory', array('%directory' => $directory), WATCHDOG_ERROR);
      return FALSE;
    }

    $file = file_load($node->{'field_bgimage_image'}[LANGUAGE_NONE][0]['fid']);
    $destination = $directory . $obfuscate . '.jpg';
    // A file with uri == $destination is a file we've already processed and
    // moved; avoid an error by not trying to replace it with itself.
    if ($file->uri != $destination) {
      // Move file into scalable file area, e.g.
      // files/raw/7H3/HEH/7H3HEHUZ6H3HMLUZ8LWZUHLRUHVZMLZR5LAZ8LUZ6HBH0L6Z4H6ZLLOHIHBHQL5Z8H.jpg
      file_move($file, $destination);
    }
  }
}

/**
 * Extracts data from a bgimage node to be stored in bgimage table.
 *
 * @param object @node
 *   A bgimage node.
 * @return array
 *   An array containing the data to be saved in the database.
 */
function _bgimage_prepare($node) {
  $wrapper = entity_metadata_wrapper('node', $node);

  $male = 0;
  $female = 0;
  foreach ($wrapper->field_bgimage_sex->value() as $selected_value) {
    if ($selected_value == 'female') {
      $female = 1;
    }
    elseif ($selected_value == 'male') {
      $male = 1;
    }
  }

  $egg = 0;
  $immature = 0;
  $pupa = 0;
  $adult = 0;
  foreach ($wrapper->field_bgimage_life_stage->value() as $selected_value) {
    if ($selected_value == 'immature') {
      $immature = 1;
    }
    elseif ($selected_value == 'adult') {
      $adult = 1;
    }
  }

  // Fetch image details.
  $width = 0;
  $height = 0;
  $filesize = 0;
  $image_data = $wrapper->field_bgimage_image->value();
  if (!empty($image_data)) {
    $width = $image_data['width'];
    $height = $image_data['height'];
    // Oopsie, the field does not store the filesize.
  }

  $fields = array(
    'nid' => $node->nid,
    'parent' => $wrapper->field_parent->value() ? $wrapper->field_parent->value() : 0,
    'parent_idx' => $wrapper->field_parent->value() . ',',
    'base' => $wrapper->field_bgimage_base->value(),
    'id' => $wrapper->field_bgimage_id->value(),
    'location' => $wrapper->field_bgimage_location->value(),
    'date_taken' => $wrapper->field_bgimage_date->value(),
    'width' => $width,
    'height' => $height,
    'filesize' => $filesize,
    'weight' => 0,
    'representative' => 0,
    'male' => $male,
    'female' => $female,
    'adult' => $adult,
    'immature' => $immature,
    'size' => $wrapper->field_bgimage_size->value(),
    'owner' => $wrapper->field_bgimage_copyright_owner->value(),
    'county' => $wrapper->field_bgimage_county->value(),
    'location_code' => $wrapper->field_bgimage_location_code->value(),
  );

  return $fields;
}

/**
 * Modify paths of derivative images.
 *
 * @param string $result
 *   $result = $scheme . '://styles/' . $style_name . '/' . $scheme . '/' . $path;
 * @param unknown_type $context
 *   $context = array(
 *     'style_name' => $style_name,
 *     'uri' => $uri,
 *     'scheme' => $scheme,
 *     'path' => $path,
 *   );
 */
function bgimage_image_style_path_alter(&$style_path, $context) {
  // Only modify path if a derivative of a raw image was requested, like
  // raw/ELI/RTZ/ELIRTZ8RTL8RZH4ROLXZALIZNLYLCZQRYZMRFZ0RCZIROZRZCLMZRH0RFZFL3ZRZOZ.jpg
  if (substr($context['path'], 0, 4) != 'raw/') {
    return;
  }

  $s = pathinfo($context['path'], PATHINFO_FILENAME);
  // 7H3HEHUZ6H3HMLUZ8LWZUHLRUHVZMLZR5LAZ8LUZ6HBH0L6Z4H6ZLLOHIHBHQL5Z8H

  $uuid = image_deobfuscate($s);
  // faed59f39f56052153b48643f20ee94e

  $path = image_obfuscate($uuid . ',' . $context['style_name']) . '.jpg';
  // NH8ZYZMZZHIZOZZRILVZQLVHQLEZSL1HXHCHIHYHNHAZ8LNZMLUZGLAZIL1Z2HAHMH2ZGLUZUH9Z2H1Z.jpg

  $prefix = bgimage_get_prefix($path);
  // NH8/ZYZ/

  $style_path = $context['scheme'] . '://styles/' . $context['style_name'] . '/' . $context['scheme'] . '/' . $prefix . $path;
  // public://styles/medium/public/NH8/ZYZ/NH8ZYZMZZHIZOZZRILVZQLVHQLEZSL1HXHCHIHYHNHAZ8LNZMLUZGLAZIL1Z2HAHMH2ZGLUZUH9Z2H1Z.jpg
}

/**
 * Given URI of a derivative, return URI of original.
 */
function bgimage_original_from_derivative_path($scheme, $target) {
  // Only attempt to get original URI for scalable targets like
  // NH8/ZYZ/NH8ZYZMZZHIZOZZRILVZQLVHQLEZSL1HXHCHIHYHNHAZ8LNZMLUZGLAZIL1Z2HAHMH2ZGLUZUH9Z2H1Z.jpg
  if (strlen($target) < 8 || $target[3] != '/' || $target[7] != '/') {
    // Stock Drupal image_uri.
    return $scheme . '://' . $target;
  }

  $s = pathinfo($target, PATHINFO_FILENAME);
  // NH8ZYZMZZHIZOZZRILVZQLVHQLEZSL1HXHCHIHYHNHAZ8LNZMLUZGLAZIL1Z2HAHMH2ZGLUZUH9Z2H1Z

  $info = image_deobfuscate($s);
  // faed59f39f56052153b48643f20ee94e,medium

  $parts = explode(',', $info);
  $uuid = array_shift($parts);
  // faed59f39f56052153b48643f20ee94e

  $obfuscated = image_obfuscate($uuid);
  // ELIRTZ8RTL8RZH4ROLXZALIZNLYLCZQRYZMRFZ0RCZIROZRZCLMZRH0RFZFL3ZRZOZ

  $prefix = bgimage_get_prefix($obfuscated);
  // ELI/RTZ/

  return $scheme . '://' . 'raw/' . $prefix . $obfuscated . '.jpg';
  // public://raw/ELI/RTZ/ELIRTZ8RTL8RZH4ROLXZALIZNLYLCZQRYZMRFZ0RCZIROZRZCLMZRH0RFZFL3ZRZOZ.jpg
}

/**
 * Implements hook_clone_node_alter().
 *
 * @param $node
 *   Reference to the fully loaded node object being saved (the clone) that
 *   can be altered as needed.
 * @param array $context
 *   An array of context describing the clone operation. The keys are:
 *   - 'method' : Can be either 'prepopulate' or 'save-edit'.
 *   - 'original_node' : The original fully loaded node object being cloned.
 *
 * @see clone_node_save()
 * @see drupal_alter()
 */
function bgimage_clone_node_alter(&$node, $context) {
  if ($context['method'] == 'prepopulate') {
    // Don't prepopulate the image field or the base field.
    $node->field_bgimage_image = array(LANGUAGE_NONE => array());
    $node->field_bgimage_base = array(LANGUAGE_NONE => array());
    // Remove "Clone of".
    $node->title = str_replace('Clone of ', '', $node->title);
    drupal_set_title($node->title);
    // Add the original nid in order to update bgimage_series.
    $base_nid = _bgimage_get_series_base($context['original_node']->nid);
    $node->original_nid = $base_nid ? $base_nid : $context['original_node']->nid;
  }
}

/**
 * Altered menu title callback for cloning a bgimage node.
 */
function _bgimage_clone_action_link_title($node) {
  // A hack to present a shorter title in contextual links.
  if (current_path() != 'node/' . $node->nid) {
    return t('Clone');
  }
  if (variable_get('clone_use_node_type_name', 0)) {
    return t('Clone this !type', array('!type' => drupal_strtolower(node_type_get_name($node))));
  }
  return t('Add image of this individual');
}

/**
 * Implements hook_clone_access_alter().
 *
 * @see clone_access_cloning()
 */
function bgimage_clone_access_alter(&$access, $node) {
  // So far clone_access_cloning() has checked permissions. Deny cloning on nodes that are not bgimage nodes.
  if ($node->type != 'bgimage') {
    $access = FALSE;
  }
}

/**
 * Menu callback. View all clipped images at regular size for comparison.
 * See preprocess function below.
 */
function bgimage_view_clipped() {
  return theme('photo_comparison');
}

/**
 * Implements hook_block_info().
 */
function bgimage_block_info() {
  $blocks['clipped_images'] = array(
     'info' => t('Image Clipboard'),
     'cache' => DRUPAL_NO_CACHE,
   );
  return $blocks;
}

/**
 * Implements hook_block_view().
 * The changes in HTML and CSS are to allow for the bulma.io Panel Component
 * https://bulma.io/documentation/components/panel/
 */
function bgimage_block_view($delta = '') {
  if (empty($_SESSION['clipboard_images'])) {
    return array();
  }

  // We return images wrapped by divs, and the controls.
  global $user;
  $content = '';
  $nids = explode(',', $_SESSION['clipboard_images']);
  $clip_count = 0;
  $same_uid = TRUE;
  $nodes = node_load_multiple($nids);
  $content = '<ul class="item-list panel-block flex-wrap">';
  foreach ($nodes as $node) {
    // Check if all images belong to the same user.
    if ($user->uid != $node->uid) {
      $same_uid = FALSE;
    }

    // Render a thumbnail of the image.
    $rendered_image = theme('image_style', array('path' => $node->field_bgimage_image[LANGUAGE_NONE][0]['uri'], 'style_name' => 'bg_small'));
    $content .= '<li class="mb-2 mr-2">';
    $content .= '<a class="is-block" href="' . url('node/' . $node->nid) . '" title="' . check_plain($node->title) . '">' . $rendered_image  . '</a>';
    $content .= l(t('<span class="icon is-small"><span class="fa fa-times" aria-hidden="true"></span></span><span>Remove</span>'), 'bgimage/unclip/' . $node->nid, array(
      'attributes' => array(
        'title' => t('Remove this image from the clipboard'),
        'class' => 'clip-remove button is-small',
        ),
      'query' => array('destination' => current_path()),
      'html' => TRUE,
    ));
    $content .= '</li>';
    $clip_count++;
  }
  $content .= '</ul>';

  $links = array();
  if ($clip_count > 1) {
    $links[] = l(t('<span class="icon is-small"><span class="fa fa-times" aria-hidden="true"></span></span><span>Remove all</span>'), 'bgimage/unclip_all', array(
      'attributes' => array(
        'title' => t('Remove these images from the clipboard'),
        'class' => 'clip-remove-all button is-small mr-1 mb-1',
        ),
      'query' => array('destination' => current_path()),
      'html' => TRUE,
    ));
  }

  if ($clip_count > 1 && ($same_uid || user_access('link all bgimages'))) {
    $links[] = l(t('<span class="icon is-small"><span class="fa fa-link" aria-hidden="true"></span></span><span>Link</span>'), 'bgimage/link', array(
      'attributes' => array(
        'title' => t('Link together these images of the same specimen.'),
        'class' => 'clip-link button is-small mr-1 mb-1',
        ),
      'query' => array('destination' => current_path()),
      'html' => TRUE,
    ));
  }

  $current_menu_item = menu_get_item();
  if (!empty($current_menu_item) && $current_menu_item['path'] == "node/%/bgimage" && ($same_uid || user_access('move all bgimages'))) {
    $current_nid = (int) arg(1);
    $links[] = l(t('<span class="icon is-small"><span class="fa fa-long-arrow-right" aria-hidden="true"></span></span><span>Move'), 'bgimage/move/' . $current_nid, array(
      'attributes' => array(
        'title' => t('Move these images to the taxonomy of the current page.'),
        'class' => 'clip-move button is-small mr-1 mb-1',
        ),
      'html' => TRUE,
    ));
    if (user_access('quiet move all bgimages')) {
      $links[] = l(t('<span class="icon is-small"><span class="fa fa-long-arrow-right" aria-hidden="true"></span></span><span>Quiet move</span>'), 'bgimage/quiet_move/' . $current_nid, array(
        'attributes' => array(
          'title' => t('Quietly move these images to the taxonomy of the current page.'),
          'class' => 'clip-move button is-small mb-1',
          ),
        'html' => TRUE,
      ));
    }
  }

  $content .= '<div class="panel-block flex-wrap">'. implode(' ', $links) . '</div>';

  return array(
    'subject' => t('Clipboard'),
    'content' => $content,
  );
}

/**
 * Returns the base series nid (i.e. the first image in the series) for a given
 * nid.
 *
 * @param int $nid
 *   The nid of a node that belongs to a series.
 * return int|NULL
 *   The series nid if $nid belongs to a series, or NULL if not.
 */
function _bgimage_get_series_base($nid) {
  // First, check if there are related images.
  $result = db_query('SELECT series FROM {bgimage_series} WHERE nid = :nid', array(':nid' => $nid))->fetchAssoc();
  // fetchAssoc() returns FALSE if no results, otherwise an associative array.
  return $result ? $result['series'] : NULL;
}

/**
 * Returns a series of images given an nid.
 *
 * @param int $nid
 *   The nid of a node that belongs to the series.
 * return array|NULL
 *   An array of nids or NULL if the nid does not belong to a series.
 */
function bgimage_get_series($nid) {
  $series_base_nid = _bgimage_get_series_base($nid);
  if (!$series_base_nid) {
    return NULL;
  }

  // Next, extract the nids of all the images in the series.
  $nids = db_query('SELECT nid FROM {bgimage_series} WHERE series = :nid ORDER BY weight', array(':nid' => $series_base_nid))->fetchCol();

  return $nids;
}

/**
 * This is a #process function for the image field of the bgimage_node_form -
 * the file module's upload functionality is added through #process functions
 * (file_managed_file_process in particular for the AJAX code we're dealing with
 * here) which get processed after hook_form_alter calls, so another #process
 * function is the only way to alter that upload code.
 *
 * @param array $element
 *   The field_bgimage_image portion of the bgimage_node_form.
 *
 * @see file_managed_file_process().
 */
function field_bgimage_image_process($element, $form_state, $form) {
  // We're wrapping managed_file's upload AJAX with our own so that we can add
  // extra functionality.
  unset($element['upload_button']['#ajax']['path']);
  $element['upload_button']['#ajax']['callback'] = 'bgimage_image_ajax_callback';
  return $element;
}

/**
 * Drupal AJAX callback function which wraps the managed-file file upload AJAX
 * code. Our addition to that functionality is to update the date field in the
 * $form using EXIF data from the uploaded image (when it includes a date taken
 * value).
 *
 * @param array $form
 *   The form on which the AJAX call has been made.
 *
 * @return array
 *   An array of Drupal AJAX commands for updating the form.
 *
 * @see file_ajax_upload();
 * @see file_save_upload();
 */
function bgimage_image_ajax_callback($form, $form_state) {
  // Let the managed-file upload code do its AJAX work, which includes uploading
  // the file and marking its files_managed record temporary (status = 0).
  // The return value is an array of Drupal AJAX commands for updating the
  // field_bgimage_image form element.
  $ajax_commands = file_ajax_upload('field_bgimage_image', 'und', '0', $form['form_build_id']['#value']);

  // User clicked Extract image data button with no file selected, or selected a
  // non-jpg file. Do nothing.
  if (!isset($form_state['field']['field_bgimage_image'][LANGUAGE_NONE]['items'][0]['fid'])) {
    return $ajax_commands;
  }

  $fid = $form_state['field']['field_bgimage_image'][LANGUAGE_NONE]['items'][0]['fid'];
  $file_uri = file_load($fid)->uri;
  if (!$file_uri) {
    // Somehow the temporary file record did not make it into the files_managed
    // database table. Perhaps upload was interrupted. Do nothing.
    return $ajax_commands;
  }

  $exif_metadata = @exif_read_data($file_uri);

  if (isset($exif_metadata['DateTime'])) {
    // https://web.archive.org/web/20190624045241if_/http://www.cipa.jp:80/std/documents/e/DC-008-Translation-2019-E.pdf
    // The EXIF standard for datetime is "YYYY:MM:DD HH:MM:SS"
    // e.g., 2021:10:12 22:32:46
    // Strip off the time portion, leaving just the date.
    $exif_date = substr($exif_metadata['DateTime'], 0, 10);
    // Now put it in the format the date picker expects.
    $exif_date = date_create_from_format('Y:m:d', $exif_date)->format('n/j/Y');
    $form['field_bgimage_date'][LANGUAGE_NONE][0]['value']['date']['#value'] = $exif_date;

    // Re-render just the date field to replace the current markup.
    $new_date_markup = drupal_render($form['field_bgimage_date']);

    // It's not clear if/how these js settings are used, but file_ajax_upload
    // does it, so we do too.
    $js = drupal_add_js();
    $settings = drupal_array_merge_deep_array($js['settings']['data']);
    // Create the Drupal AJAX command for replacing the current date field.
    // Targeting class field-name-field-bgimage-date.
    $ajax_commands['#commands'][] = ajax_command_replace('.field-name-field-bgimage-date', $new_date_markup, $settings);
  }

  return $ajax_commands;
}

/**
 * Implements hook_date_text_process_alter().
 */
function bgimage_date_text_process_alter(&$element, $form_state, $context) {
  if (isset($element['date']['#description'])) {
    // Hide the 'Format: 9/22/21' help text since we provide our own format
    // hint in our field description.
    unset($element['date']['#description']);
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function bgimage_form_bgimage_node_form_alter(&$form, &$form_state) {
  // Only allow users with Administer content permission to edit some fields.
  if (!user_access('administer nodes')) {
    $form['field_parent']['#access'] = FALSE;
    $form['field_bgimage_base']['#access'] = FALSE;
  }

  // Add an additional #process function on the image field so that we can alter
  // the results of other #process functions which run after hook_form_alter.
  $form['field_bgimage_image'][LANGUAGE_NONE][0]['#process'][] = 'field_bgimage_image_process';

  // Add a second submit button which allows the user to apply (most of) the
  // settings in the current form to all images in this series, but only if
  // we're currently cloning an image or this image is already one in a series.
  $clone_submission = isset($form['#node']->original_nid);

  // Figure out which nid to use to test for other images in this series.
  $series_test_nid = NULL;
  if (isset($form['#node']->nid)) {
    $series_test_nid = $form['#node']->nid;
  }
  elseif ($clone_submission) {
    // $form['#node']->nid will be NULL for a cloned node whose nid hasn't been
    // assigned yet. In that case, we should be $clone_submission, and we'll get
    // our series info from the nid we were cloned from.
    $series_test_nid = $form['#node']->original_nid;
  }
  $series = $series_test_nid ? bgimage_get_series($series_test_nid) : NULL;

  if ($clone_submission || $series !== NULL) {
    $other_images_count = 0;
    if ($series === NULL) {
      // If $series === NULL then there was no series, so we're the first clone of
      // an image, i.e. there's one other image in this series.
      if ($clone_submission) {
        $other_images_count = 1;
      }
    }
    else {
      // If this wasn't a clone submission then the current image is already
      // included in the series.
      $other_images_count = $clone_submission ? count($series) : count($series) - 1;
    }

    if ($other_images_count > 0) {
      $form['actions']['save-and-sync'] = array(
        '#type' => 'submit',
        '#value' => t('Save & Sync'),
        '#attributes' => array('id' => 'edit-submit-save-and-sync'),
        '#weight' => 8,
        '#submit' => array('node_form_submit', '_bgimage_save_and_sync_submit'),
      );

      $save_and_sync_markup = format_plural($other_images_count, '<div><b>Save & Sync</b> will use information on this form (except Identifier, Image, Remarks and Tags) to update the information on the other submission of this individual.</div>', '<div><b>Save & Sync</b> will use information on this form (except Identifier, Image, Remarks and Tags) to update the information on the other @count submissions of this individual.</div>');
      $form['actions']['#suffix'] = $save_and_sync_markup;
    }
  }
}

function _bgimage_save_and_sync_submit($form, &$form_state) {
  if (!isset($form_state['triggering_element']['#value']) || $form_state['triggering_element']['#value'] != 'Save & Sync') {
    return;
  }

  $form_nid = isset($form['#node']->nid) ? $form['#node']->nid : NULL;
  $series_nids = array();
  if ($form_nid) {
    $series_nids = bgimage_get_series($form_nid);
    if ($series_nids == NULL) {
      return;
    }
  }
  elseif (isset($form['#node']->original_nid)) {
    // The submitted node is a not-yet-inserted clone, so get the image series
    // of the node cloned from.
    $series_nids = bgimage_get_series($form['#node']->original_nid);
    if (!$series_nids) {
      // This cloned node is the second in the series, so the series hasn't been
      // saved in the database yet - just use the original as our series.
      $series_nids = array($form['#node']->original_nid);
    }
  }

  foreach ($series_nids as $nid) {
    if ($nid == $form_nid) {
      continue;
    }
    $wrapper = entity_metadata_wrapper('node', $nid);

    if (isset($form_state['build_info']['args']['0']->title)) {
      $wrapper->title->set($form_state['build_info']['args']['0']->title);
    }

    $simple_values = array(
      'field_bgimage_location_code', 'field_bgimage_county',
      'field_bgimage_location', 'field_bgimage_size',
      'field_bgimage_copyright_owner'
    );
    foreach ($simple_values as $simple_value) {
      if (isset($form_state['values'][$simple_value][LANGUAGE_NONE][0]['value'])) {
        if ($form_state['values'][$simple_value][LANGUAGE_NONE][0]['value'] != '') {
          $wrapper->$simple_value->set($form_state['values'][$simple_value][LANGUAGE_NONE][0]['value']);
        }
        elseif ($simple_value != 'field_bgimage_location_code') {
          // If you store an empty string for a field, it will cause the field
          // to be displayed on a bgimage page even though there's no value to
          // display - instead what we want to do here is remove the field for
          // this image from the database.
          $wrapper->$simple_value->set(NULL);
        }
      }
    }

    $multivalue_fields = array(
      'field_bgimage_sex', 'field_bgimage_life_stage'
    );
    foreach ($multivalue_fields as $multivalue_field) {
      if (isset($form_state['values'][$multivalue_field][LANGUAGE_NONE])) {
        $value = $form_state['values'][$multivalue_field][LANGUAGE_NONE];
        // Multivalue fields contain one array element for each item that was
        // checked; if the first value is NULL that means nothing was checked.
        if ($value[0]['value'] == NULL) {
          // Need to use an empty array to unset a multivalue field.
          $value = array();
        }
        $wrapper->$multivalue_field->set($value);
      }
    }

    // Setting dates using entity_metadata_wrapper is buggy for dates before
    // 1/1/1970 (i.e. dates with negative unix timestamp), so avoid that route -
    // see the discussion at https://github.com/bugguide/bugguide/pull/276.
    if (isset($form_state['values']['field_bgimage_date'][LANGUAGE_NONE][0]) &&
        is_array($form_state['values']['field_bgimage_date'][LANGUAGE_NONE][0]) &&
        array_key_exists('value', $form_state['values']['field_bgimage_date'][LANGUAGE_NONE][0])) {
      $series_node = $wrapper->value();
      // $wrapper->save() below calls node_save, so we won't do so here.
      if ($form_state['values']['field_bgimage_date'][LANGUAGE_NONE][0]['value'] !== NULL) {
        $series_node->field_bgimage_date[LANGUAGE_NONE][0]['value'] = $form_state['values']['field_bgimage_date'][LANGUAGE_NONE][0]['value'];
      }
      else {
        // A NULL 'value' indicates that the date input in the form was empty,
        // so remove this date field from the database.
        unset($series_node->field_bgimage_date[LANGUAGE_NONE][0]);
      }
    }

    $wrapper->save();
  }
}

/**
 * Implements hook_views_pre_render().
 *
 * @param $view
 *   The view object.
 */
function bgimage_views_pre_render(&$view) {
  // For recent images views with display block show just 4 recent images
  // that doesn't contain ID Request as a parent.
  if (($view->name === 'recent_images') && ($view->current_display == 'block')) {
    $nids_not_in_id_request = 0;
    foreach ($view->result as $key => $record) {
      $node = node_load($record->nid);
      $parent_value = bg_get_first_parent_nid($node);
      if ($parent_value && $parent_value != BG_ID_REQUEST_NID && $nids_not_in_id_request < 4) {
        $series_base = _bgimage_get_series_base($record->nid);
        // (1) nid is not a member of a series and $series_base is NULL - keep
        // (2) nid is a member of the series and the series base - keep
        // (3) nid is a member of the series but not the series base - discard
        // To match (3) a result is present in $series_base and it is not the nid of the
        // record. Nest this if() so that series queries are only done on nids that have
        // passed the other tests.
        if ($series_base && $record->nid != $series_base) {
          unset($view->result[$key]);
          continue;
        }
        $nids_not_in_id_request++;
      }
      else {
        // Remove ID Request result.
        unset($view->result[$key]);
      }
    }
  }
}
